// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Vo.proto

#ifndef PROTOBUF_Vo_2eproto__INCLUDED
#define PROTOBUF_Vo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Vo_2eproto();
void protobuf_AssignDesc_Vo_2eproto();
void protobuf_ShutdownFile_Vo_2eproto();

class UserBase;
class UserInfo;
class Rank;
class Prop;
class Reward;
class ShopItem;
class Mail;
class FriendNotice;
class Friend;
class Active;
class Status;
class Task;
class ExAward;
class ExRecord;
class SignAward;
class SignZhuan;
class PayRecord;
class RoomData;
class CPGCardData;
class RoomUser;
class TingCard;
class UserOver;
class UserRound;
class CPing;
class SPing;

// ===================================================================

class UserBase : public ::google::protobuf::Message {
 public:
  UserBase();
  virtual ~UserBase();

  UserBase(const UserBase& from);

  inline UserBase& operator=(const UserBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBase& default_instance();

  void Swap(UserBase* other);

  // implements Message ----------------------------------------------

  UserBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserBase& from);
  void MergeFrom(const UserBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional uint32 sex = 3 [default = 1];
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional uint32 gold = 6 [default = 4000];
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 6;
  inline ::google::protobuf::uint32 gold() const;
  inline void set_gold(::google::protobuf::uint32 value);

  // optional uint32 diamond = 7 [default = 8];
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 7;
  inline ::google::protobuf::uint32 diamond() const;
  inline void set_diamond(::google::protobuf::uint32 value);

  // optional uint32 card = 8 [default = 1];
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 8;
  inline ::google::protobuf::uint32 card() const;
  inline void set_card(::google::protobuf::uint32 value);

  // optional uint32 picid = 9 [default = 1];
  inline bool has_picid() const;
  inline void clear_picid();
  static const int kPicidFieldNumber = 9;
  inline ::google::protobuf::uint32 picid() const;
  inline void set_picid(::google::protobuf::uint32 value);

  // optional string picurl = 10;
  inline bool has_picurl() const;
  inline void clear_picurl();
  static const int kPicurlFieldNumber = 10;
  inline const ::std::string& picurl() const;
  inline void set_picurl(const ::std::string& value);
  inline void set_picurl(const char* value);
  inline void set_picurl(const char* value, size_t size);
  inline ::std::string* mutable_picurl();
  inline ::std::string* release_picurl();
  inline void set_allocated_picurl(::std::string* picurl);

  // optional string phone = 11;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 11;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional uint32 win = 12 [default = 0];
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 12;
  inline ::google::protobuf::uint32 win() const;
  inline void set_win(::google::protobuf::uint32 value);

  // optional uint32 lose = 13 [default = 0];
  inline bool has_lose() const;
  inline void clear_lose();
  static const int kLoseFieldNumber = 13;
  inline ::google::protobuf::uint32 lose() const;
  inline void set_lose(::google::protobuf::uint32 value);

  // optional uint32 ping = 14 [default = 0];
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 14;
  inline ::google::protobuf::uint32 ping() const;
  inline void set_ping(::google::protobuf::uint32 value);

  // optional uint32 vip = 15 [default = 0];
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 15;
  inline ::google::protobuf::uint32 vip() const;
  inline void set_vip(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.UserBase)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  inline void set_has_card();
  inline void clear_has_card();
  inline void set_has_picid();
  inline void clear_has_picid();
  inline void set_has_picurl();
  inline void clear_has_picurl();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_lose();
  inline void clear_has_lose();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_vip();
  inline void clear_has_vip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* username_;
  ::std::string* ip_;
  ::google::protobuf::uint32 sex_;
  ::google::protobuf::uint32 gold_;
  ::std::string* address_;
  ::google::protobuf::uint32 diamond_;
  ::google::protobuf::uint32 card_;
  ::std::string* picurl_;
  ::google::protobuf::uint32 picid_;
  ::google::protobuf::uint32 win_;
  ::std::string* phone_;
  ::google::protobuf::uint32 lose_;
  ::google::protobuf::uint32 ping_;
  ::google::protobuf::uint32 vip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static UserBase* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.UserBase info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::protocol::UserBase& info() const;
  inline ::protocol::UserBase* mutable_info();
  inline ::protocol::UserBase* release_info();
  inline void set_allocated_info(::protocol::UserBase* info);

  // optional uint32 online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline ::google::protobuf::uint32 online() const;
  inline void set_online(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.UserInfo)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_online();
  inline void clear_has_online();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::UserBase* info_;
  ::google::protobuf::uint32 online_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class Rank : public ::google::protobuf::Message {
 public:
  Rank();
  virtual ~Rank();

  Rank(const Rank& from);

  inline Rank& operator=(const Rank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rank& default_instance();

  void Swap(Rank* other);

  // implements Message ----------------------------------------------

  Rank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rank& from);
  void MergeFrom(const Rank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 lv = 1;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 1;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .protocol.UserBase info = 4;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 4;
  inline const ::protocol::UserBase& info() const;
  inline ::protocol::UserBase* mutable_info();
  inline ::protocol::UserBase* release_info();
  inline void set_allocated_info(::protocol::UserBase* info);

  // @@protoc_insertion_point(class_scope:protocol.Rank)
 private:
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 lv_;
  ::google::protobuf::uint32 type_;
  ::protocol::UserBase* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Rank* default_instance_;
};
// -------------------------------------------------------------------

class Prop : public ::google::protobuf::Message {
 public:
  Prop();
  virtual ~Prop();

  Prop(const Prop& from);

  inline Prop& operator=(const Prop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Prop& default_instance();

  void Swap(Prop* other);

  // implements Message ----------------------------------------------

  Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Prop& from);
  void MergeFrom(const Prop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:protocol.Prop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Prop* default_instance_;
};
// -------------------------------------------------------------------

class Reward : public ::google::protobuf::Message {
 public:
  Reward();
  virtual ~Reward();

  Reward(const Reward& from);

  inline Reward& operator=(const Reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reward& default_instance();

  void Swap(Reward* other);

  // implements Message ----------------------------------------------

  Reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reward& from);
  void MergeFrom(const Reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rid = 1;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRidFieldNumber = 1;
  inline ::google::protobuf::uint32 rid() const;
  inline void set_rid(::google::protobuf::uint32 value);

  // optional .protocol.Prop prop = 2;
  inline bool has_prop() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 2;
  inline const ::protocol::Prop& prop() const;
  inline ::protocol::Prop* mutable_prop();
  inline ::protocol::Prop* release_prop();
  inline void set_allocated_prop(::protocol::Prop* prop);

  // optional uint32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Reward)
 private:
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_prop();
  inline void clear_has_prop();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::Prop* prop_;
  ::google::protobuf::uint32 rid_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Reward* default_instance_;
};
// -------------------------------------------------------------------

class ShopItem : public ::google::protobuf::Message {
 public:
  ShopItem();
  virtual ~ShopItem();

  ShopItem(const ShopItem& from);

  inline ShopItem& operator=(const ShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShopItem& default_instance();

  void Swap(ShopItem* other);

  // implements Message ----------------------------------------------

  ShopItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShopItem& from);
  void MergeFrom(const ShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .protocol.Reward prop = 2;
  inline bool has_prop() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 2;
  inline const ::protocol::Reward& prop() const;
  inline ::protocol::Reward* mutable_prop();
  inline ::protocol::Reward* release_prop();
  inline void set_allocated_prop(::protocol::Reward* prop);

  // optional .protocol.Reward consume = 3;
  inline bool has_consume() const;
  inline void clear_consume();
  static const int kConsumeFieldNumber = 3;
  inline const ::protocol::Reward& consume() const;
  inline ::protocol::Reward* mutable_consume();
  inline ::protocol::Reward* release_consume();
  inline void set_allocated_consume(::protocol::Reward* consume);

  // optional .protocol.Reward give = 4;
  inline bool has_give() const;
  inline void clear_give();
  static const int kGiveFieldNumber = 4;
  inline const ::protocol::Reward& give() const;
  inline ::protocol::Reward* mutable_give();
  inline ::protocol::Reward* release_give();
  inline void set_allocated_give(::protocol::Reward* give);

  // optional bool hot = 5;
  inline bool has_hot() const;
  inline void clear_hot();
  static const int kHotFieldNumber = 5;
  inline bool hot() const;
  inline void set_hot(bool value);

  // @@protoc_insertion_point(class_scope:protocol.ShopItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_prop();
  inline void clear_has_prop();
  inline void set_has_consume();
  inline void clear_has_consume();
  inline void set_has_give();
  inline void clear_has_give();
  inline void set_has_hot();
  inline void clear_has_hot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::Reward* prop_;
  ::protocol::Reward* consume_;
  ::google::protobuf::uint32 id_;
  bool hot_;
  ::protocol::Reward* give_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static ShopItem* default_instance_;
};
// -------------------------------------------------------------------

class Mail : public ::google::protobuf::Message {
 public:
  Mail();
  virtual ~Mail();

  Mail(const Mail& from);

  inline Mail& operator=(const Mail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mail& default_instance();

  void Swap(Mail* other);

  // implements Message ----------------------------------------------

  Mail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mail& from);
  void MergeFrom(const Mail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eid = 1;
  inline bool has_eid() const;
  inline void clear_eid();
  static const int kEidFieldNumber = 1;
  inline ::google::protobuf::uint32 eid() const;
  inline void set_eid(::google::protobuf::uint32 value);

  // optional string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // repeated .protocol.Reward rewardlist = 6;
  inline int rewardlist_size() const;
  inline void clear_rewardlist();
  static const int kRewardlistFieldNumber = 6;
  inline const ::protocol::Reward& rewardlist(int index) const;
  inline ::protocol::Reward* mutable_rewardlist(int index);
  inline ::protocol::Reward* add_rewardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reward >&
      rewardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Reward >*
      mutable_rewardlist();

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Mail)
 private:
  inline void set_has_eid();
  inline void clear_has_eid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::std::string* content_;
  ::google::protobuf::uint32 eid_;
  ::google::protobuf::uint32 status_;
  ::std::string* time_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Reward > rewardlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Mail* default_instance_;
};
// -------------------------------------------------------------------

class FriendNotice : public ::google::protobuf::Message {
 public:
  FriendNotice();
  virtual ~FriendNotice();

  FriendNotice(const FriendNotice& from);

  inline FriendNotice& operator=(const FriendNotice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendNotice& default_instance();

  void Swap(FriendNotice* other);

  // implements Message ----------------------------------------------

  FriendNotice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendNotice& from);
  void MergeFrom(const FriendNotice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 nid = 1;
  inline bool has_nid() const;
  inline void clear_nid();
  static const int kNidFieldNumber = 1;
  inline ::google::protobuf::uint32 nid() const;
  inline void set_nid(::google::protobuf::uint32 value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional uint32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.FriendNotice)
 private:
  inline void set_has_nid();
  inline void clear_has_nid();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* uid_;
  ::google::protobuf::uint32 nid_;
  ::google::protobuf::uint32 status_;
  ::std::string* time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static FriendNotice* default_instance_;
};
// -------------------------------------------------------------------

class Friend : public ::google::protobuf::Message {
 public:
  Friend();
  virtual ~Friend();

  Friend(const Friend& from);

  inline Friend& operator=(const Friend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Friend& default_instance();

  void Swap(Friend* other);

  // implements Message ----------------------------------------------

  Friend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Friend& from);
  void MergeFrom(const Friend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.UserBase info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::protocol::UserBase& info() const;
  inline ::protocol::UserBase* mutable_info();
  inline ::protocol::UserBase* release_info();
  inline void set_allocated_info(::protocol::UserBase* info);

  // optional bool online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline bool online() const;
  inline void set_online(bool value);

  // optional bool friend = 3;
  inline bool has_friend_() const;
  inline void clear_friend_();
  static const int kFriendFieldNumber = 3;
  inline bool friend_() const;
  inline void set_friend_(bool value);

  // optional uint32 acttype = 4;
  inline bool has_acttype() const;
  inline void clear_acttype();
  static const int kActtypeFieldNumber = 4;
  inline ::google::protobuf::uint32 acttype() const;
  inline void set_acttype(::google::protobuf::uint32 value);

  // optional uint32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Friend)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_friend_();
  inline void clear_has_friend_();
  inline void set_has_acttype();
  inline void clear_has_acttype();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::UserBase* info_;
  bool online_;
  bool friend__;
  ::google::protobuf::uint32 acttype_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Friend* default_instance_;
};
// -------------------------------------------------------------------

class Active : public ::google::protobuf::Message {
 public:
  Active();
  virtual ~Active();

  Active(const Active& from);

  inline Active& operator=(const Active& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Active& default_instance();

  void Swap(Active* other);

  // implements Message ----------------------------------------------

  Active* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Active& from);
  void MergeFrom(const Active& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:protocol.Active)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Active* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 fcount = 2;
  inline bool has_fcount() const;
  inline void clear_fcount();
  static const int kFcountFieldNumber = 2;
  inline ::google::protobuf::uint32 fcount() const;
  inline void set_fcount(::google::protobuf::uint32 value);

  // optional uint32 finished = 3;
  inline bool has_finished() const;
  inline void clear_finished();
  static const int kFinishedFieldNumber = 3;
  inline ::google::protobuf::uint32 finished() const;
  inline void set_finished(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Status)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_fcount();
  inline void clear_has_fcount();
  inline void set_has_finished();
  inline void clear_has_finished();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 fcount_;
  ::google::protobuf::uint32 finished_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 taskid = 1;
  inline bool has_taskid() const;
  inline void clear_taskid();
  static const int kTaskidFieldNumber = 1;
  inline ::google::protobuf::uint32 taskid() const;
  inline void set_taskid(::google::protobuf::uint32 value);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // repeated .protocol.Reward rewardlist = 5;
  inline int rewardlist_size() const;
  inline void clear_rewardlist();
  static const int kRewardlistFieldNumber = 5;
  inline const ::protocol::Reward& rewardlist(int index) const;
  inline ::protocol::Reward* mutable_rewardlist(int index);
  inline ::protocol::Reward* add_rewardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reward >&
      rewardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Reward >*
      mutable_rewardlist();

  // optional .protocol.Status status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline const ::protocol::Status& status() const;
  inline ::protocol::Status* mutable_status();
  inline ::protocol::Status* release_status();
  inline void set_allocated_status(::protocol::Status* status);

  // @@protoc_insertion_point(class_scope:protocol.Task)
 private:
  inline void set_has_taskid();
  inline void clear_has_taskid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::google::protobuf::uint32 taskid_;
  ::google::protobuf::uint32 type_;
  ::std::string* content_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Reward > rewardlist_;
  ::protocol::Status* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class ExAward : public ::google::protobuf::Message {
 public:
  ExAward();
  virtual ~ExAward();

  ExAward(const ExAward& from);

  inline ExAward& operator=(const ExAward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExAward& default_instance();

  void Swap(ExAward* other);

  // implements Message ----------------------------------------------

  ExAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExAward& from);
  void MergeFrom(const ExAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eid = 1;
  inline bool has_eid() const;
  inline void clear_eid();
  static const int kEidFieldNumber = 1;
  inline ::google::protobuf::uint32 eid() const;
  inline void set_eid(::google::protobuf::uint32 value);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional .protocol.Reward award = 3;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 3;
  inline const ::protocol::Reward& award() const;
  inline ::protocol::Reward* mutable_award();
  inline ::protocol::Reward* release_award();
  inline void set_allocated_award(::protocol::Reward* award);

  // optional .protocol.Reward buy = 4;
  inline bool has_buy() const;
  inline void clear_buy();
  static const int kBuyFieldNumber = 4;
  inline const ::protocol::Reward& buy() const;
  inline ::protocol::Reward* mutable_buy();
  inline ::protocol::Reward* release_buy();
  inline void set_allocated_buy(::protocol::Reward* buy);

  // @@protoc_insertion_point(class_scope:protocol.ExAward)
 private:
  inline void set_has_eid();
  inline void clear_has_eid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_award();
  inline void clear_has_award();
  inline void set_has_buy();
  inline void clear_has_buy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::protocol::Reward* award_;
  ::protocol::Reward* buy_;
  ::google::protobuf::uint32 eid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static ExAward* default_instance_;
};
// -------------------------------------------------------------------

class ExRecord : public ::google::protobuf::Message {
 public:
  ExRecord();
  virtual ~ExRecord();

  ExRecord(const ExRecord& from);

  inline ExRecord& operator=(const ExRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExRecord& default_instance();

  void Swap(ExRecord* other);

  // implements Message ----------------------------------------------

  ExRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExRecord& from);
  void MergeFrom(const ExRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eid = 1;
  inline bool has_eid() const;
  inline void clear_eid();
  static const int kEidFieldNumber = 1;
  inline ::google::protobuf::uint32 eid() const;
  inline void set_eid(::google::protobuf::uint32 value);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string orderid = 3;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderidFieldNumber = 3;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional uint32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.ExRecord)
 private:
  inline void set_has_eid();
  inline void clear_has_eid();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::std::string* orderid_;
  ::google::protobuf::uint32 eid_;
  ::google::protobuf::uint32 status_;
  ::std::string* time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static ExRecord* default_instance_;
};
// -------------------------------------------------------------------

class SignAward : public ::google::protobuf::Message {
 public:
  SignAward();
  virtual ~SignAward();

  SignAward(const SignAward& from);

  inline SignAward& operator=(const SignAward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignAward& default_instance();

  void Swap(SignAward* other);

  // implements Message ----------------------------------------------

  SignAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignAward& from);
  void MergeFrom(const SignAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 day = 2;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 2;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional .protocol.Reward reward = 3;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 3;
  inline const ::protocol::Reward& reward() const;
  inline ::protocol::Reward* mutable_reward();
  inline ::protocol::Reward* release_reward();
  inline void set_allocated_reward(::protocol::Reward* reward);

  // @@protoc_insertion_point(class_scope:protocol.SignAward)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 day_;
  ::protocol::Reward* reward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static SignAward* default_instance_;
};
// -------------------------------------------------------------------

class SignZhuan : public ::google::protobuf::Message {
 public:
  SignZhuan();
  virtual ~SignZhuan();

  SignZhuan(const SignZhuan& from);

  inline SignZhuan& operator=(const SignZhuan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignZhuan& default_instance();

  void Swap(SignZhuan* other);

  // implements Message ----------------------------------------------

  SignZhuan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignZhuan& from);
  void MergeFrom(const SignZhuan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .protocol.Reward reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::protocol::Reward& reward() const;
  inline ::protocol::Reward* mutable_reward();
  inline ::protocol::Reward* release_reward();
  inline void set_allocated_reward(::protocol::Reward* reward);

  // @@protoc_insertion_point(class_scope:protocol.SignZhuan)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::Reward* reward_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static SignZhuan* default_instance_;
};
// -------------------------------------------------------------------

class PayRecord : public ::google::protobuf::Message {
 public:
  PayRecord();
  virtual ~PayRecord();

  PayRecord(const PayRecord& from);

  inline PayRecord& operator=(const PayRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayRecord& default_instance();

  void Swap(PayRecord* other);

  // implements Message ----------------------------------------------

  PayRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PayRecord& from);
  void MergeFrom(const PayRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string attach = 2;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 2;
  inline const ::std::string& attach() const;
  inline void set_attach(const ::std::string& value);
  inline void set_attach(const char* value);
  inline void set_attach(const char* value, size_t size);
  inline ::std::string* mutable_attach();
  inline ::std::string* release_attach();
  inline void set_allocated_attach(::std::string* attach);

  // optional string out_trade_no = 3;
  inline bool has_out_trade_no() const;
  inline void clear_out_trade_no();
  static const int kOutTradeNoFieldNumber = 3;
  inline const ::std::string& out_trade_no() const;
  inline void set_out_trade_no(const ::std::string& value);
  inline void set_out_trade_no(const char* value);
  inline void set_out_trade_no(const char* value, size_t size);
  inline ::std::string* mutable_out_trade_no();
  inline ::std::string* release_out_trade_no();
  inline void set_allocated_out_trade_no(::std::string* out_trade_no);

  // optional string time_start = 4;
  inline bool has_time_start() const;
  inline void clear_time_start();
  static const int kTimeStartFieldNumber = 4;
  inline const ::std::string& time_start() const;
  inline void set_time_start(const ::std::string& value);
  inline void set_time_start(const char* value);
  inline void set_time_start(const char* value, size_t size);
  inline ::std::string* mutable_time_start();
  inline ::std::string* release_time_start();
  inline void set_allocated_time_start(::std::string* time_start);

  // optional string time_expire = 5;
  inline bool has_time_expire() const;
  inline void clear_time_expire();
  static const int kTimeExpireFieldNumber = 5;
  inline const ::std::string& time_expire() const;
  inline void set_time_expire(const ::std::string& value);
  inline void set_time_expire(const char* value);
  inline void set_time_expire(const char* value, size_t size);
  inline ::std::string* mutable_time_expire();
  inline ::std::string* release_time_expire();
  inline void set_allocated_time_expire(::std::string* time_expire);

  // optional string prepay_id = 6;
  inline bool has_prepay_id() const;
  inline void clear_prepay_id();
  static const int kPrepayIdFieldNumber = 6;
  inline const ::std::string& prepay_id() const;
  inline void set_prepay_id(const ::std::string& value);
  inline void set_prepay_id(const char* value);
  inline void set_prepay_id(const char* value, size_t size);
  inline ::std::string* mutable_prepay_id();
  inline ::std::string* release_prepay_id();
  inline void set_allocated_prepay_id(::std::string* prepay_id);

  // optional string body = 7;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 7;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional string total_fee = 8;
  inline bool has_total_fee() const;
  inline void clear_total_fee();
  static const int kTotalFeeFieldNumber = 8;
  inline const ::std::string& total_fee() const;
  inline void set_total_fee(const ::std::string& value);
  inline void set_total_fee(const char* value);
  inline void set_total_fee(const char* value, size_t size);
  inline ::std::string* mutable_total_fee();
  inline ::std::string* release_total_fee();
  inline void set_allocated_total_fee(::std::string* total_fee);

  // optional string spbill_create_ip = 9;
  inline bool has_spbill_create_ip() const;
  inline void clear_spbill_create_ip();
  static const int kSpbillCreateIpFieldNumber = 9;
  inline const ::std::string& spbill_create_ip() const;
  inline void set_spbill_create_ip(const ::std::string& value);
  inline void set_spbill_create_ip(const char* value);
  inline void set_spbill_create_ip(const char* value, size_t size);
  inline ::std::string* mutable_spbill_create_ip();
  inline ::std::string* release_spbill_create_ip();
  inline void set_allocated_spbill_create_ip(::std::string* spbill_create_ip);

  // @@protoc_insertion_point(class_scope:protocol.PayRecord)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_attach();
  inline void clear_has_attach();
  inline void set_has_out_trade_no();
  inline void clear_has_out_trade_no();
  inline void set_has_time_start();
  inline void clear_has_time_start();
  inline void set_has_time_expire();
  inline void clear_has_time_expire();
  inline void set_has_prepay_id();
  inline void clear_has_prepay_id();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_total_fee();
  inline void clear_has_total_fee();
  inline void set_has_spbill_create_ip();
  inline void clear_has_spbill_create_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* attach_;
  ::std::string* out_trade_no_;
  ::std::string* time_start_;
  ::std::string* time_expire_;
  ::std::string* prepay_id_;
  ::std::string* body_;
  ::std::string* total_fee_;
  ::std::string* spbill_create_ip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static PayRecord* default_instance_;
};
// -------------------------------------------------------------------

class RoomData : public ::google::protobuf::Message {
 public:
  RoomData();
  virtual ~RoomData();

  RoomData(const RoomData& from);

  inline RoomData& operator=(const RoomData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomData& default_instance();

  void Swap(RoomData* other);

  // implements Message ----------------------------------------------

  RoomData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomData& from);
  void MergeFrom(const RoomData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 ante = 2;
  inline bool has_ante() const;
  inline void clear_ante();
  static const int kAnteFieldNumber = 2;
  inline ::google::protobuf::uint32 ante() const;
  inline void set_ante(::google::protobuf::uint32 value);

  // optional uint32 round = 3;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 3;
  inline ::google::protobuf::uint32 round() const;
  inline void set_round(::google::protobuf::uint32 value);

  // optional uint32 bao = 4;
  inline bool has_bao() const;
  inline void clear_bao();
  static const int kBaoFieldNumber = 4;
  inline ::google::protobuf::uint32 bao() const;
  inline void set_bao(::google::protobuf::uint32 value);

  // optional uint32 bang = 5;
  inline bool has_bang() const;
  inline void clear_bang();
  static const int kBangFieldNumber = 5;
  inline ::google::protobuf::uint32 bang() const;
  inline void set_bang(::google::protobuf::uint32 value);

  // optional string roomid = 6;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 6;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional string roomtype = 7;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomtypeFieldNumber = 7;
  inline const ::std::string& roomtype() const;
  inline void set_roomtype(const ::std::string& value);
  inline void set_roomtype(const char* value);
  inline void set_roomtype(const char* value, size_t size);
  inline ::std::string* mutable_roomtype();
  inline ::std::string* release_roomtype();
  inline void set_allocated_roomtype(::std::string* roomtype);

  // optional string uid = 8;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 8;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.RoomData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ante();
  inline void clear_has_ante();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_bao();
  inline void clear_has_bao();
  inline void set_has_bang();
  inline void clear_has_bang();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 ante_;
  ::google::protobuf::uint32 round_;
  ::google::protobuf::uint32 bao_;
  ::std::string* roomid_;
  ::std::string* roomtype_;
  ::std::string* uid_;
  ::google::protobuf::uint32 bang_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static RoomData* default_instance_;
};
// -------------------------------------------------------------------

class CPGCardData : public ::google::protobuf::Message {
 public:
  CPGCardData();
  virtual ~CPGCardData();

  CPGCardData(const CPGCardData& from);

  inline CPGCardData& operator=(const CPGCardData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPGCardData& default_instance();

  void Swap(CPGCardData* other);

  // implements Message ----------------------------------------------

  CPGCardData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPGCardData& from);
  void MergeFrom(const CPGCardData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional bytes cards = 2;
  inline bool has_cards() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 2;
  inline const ::std::string& cards() const;
  inline void set_cards(const ::std::string& value);
  inline void set_cards(const char* value);
  inline void set_cards(const void* value, size_t size);
  inline ::std::string* mutable_cards();
  inline ::std::string* release_cards();
  inline void set_allocated_cards(::std::string* cards);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 bei = 4;
  inline bool has_bei() const;
  inline void clear_bei();
  static const int kBeiFieldNumber = 4;
  inline ::google::protobuf::uint32 bei() const;
  inline void set_bei(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.CPGCardData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cards();
  inline void clear_has_cards();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_bei();
  inline void clear_has_bei();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cards_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 bei_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static CPGCardData* default_instance_;
};
// -------------------------------------------------------------------

class RoomUser : public ::google::protobuf::Message {
 public:
  RoomUser();
  virtual ~RoomUser();

  RoomUser(const RoomUser& from);

  inline RoomUser& operator=(const RoomUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomUser& default_instance();

  void Swap(RoomUser* other);

  // implements Message ----------------------------------------------

  RoomUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomUser& from);
  void MergeFrom(const RoomUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional uint32 picid = 3;
  inline bool has_picid() const;
  inline void clear_picid();
  static const int kPicidFieldNumber = 3;
  inline ::google::protobuf::uint32 picid() const;
  inline void set_picid(::google::protobuf::uint32 value);

  // optional string picurl = 4;
  inline bool has_picurl() const;
  inline void clear_picurl();
  static const int kPicurlFieldNumber = 4;
  inline const ::std::string& picurl() const;
  inline void set_picurl(const ::std::string& value);
  inline void set_picurl(const char* value);
  inline void set_picurl(const char* value, size_t size);
  inline ::std::string* mutable_picurl();
  inline ::std::string* release_picurl();
  inline void set_allocated_picurl(::std::string* picurl);

  // optional uint32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // optional string ip = 6;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 6;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 gold = 7;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 7;
  inline ::google::protobuf::uint32 gold() const;
  inline void set_gold(::google::protobuf::uint32 value);

  // optional uint32 score = 8;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 8;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 win = 9;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 9;
  inline ::google::protobuf::uint32 win() const;
  inline void set_win(::google::protobuf::uint32 value);

  // optional uint32 lose = 10;
  inline bool has_lose() const;
  inline void clear_lose();
  static const int kLoseFieldNumber = 10;
  inline ::google::protobuf::uint32 lose() const;
  inline void set_lose(::google::protobuf::uint32 value);

  // optional uint32 ping = 11;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 11;
  inline ::google::protobuf::uint32 ping() const;
  inline void set_ping(::google::protobuf::uint32 value);

  // optional uint32 vip = 12;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 12;
  inline ::google::protobuf::uint32 vip() const;
  inline void set_vip(::google::protobuf::uint32 value);

  // repeated .protocol.CPGCardData cpgcard = 13;
  inline int cpgcard_size() const;
  inline void clear_cpgcard();
  static const int kCpgcardFieldNumber = 13;
  inline const ::protocol::CPGCardData& cpgcard(int index) const;
  inline ::protocol::CPGCardData* mutable_cpgcard(int index);
  inline ::protocol::CPGCardData* add_cpgcard();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::CPGCardData >&
      cpgcard() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::CPGCardData >*
      mutable_cpgcard();

  // optional uint32 position = 14;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 14;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional bytes cards = 15;
  inline bool has_cards() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 15;
  inline const ::std::string& cards() const;
  inline void set_cards(const ::std::string& value);
  inline void set_cards(const char* value);
  inline void set_cards(const void* value, size_t size);
  inline ::std::string* mutable_cards();
  inline ::std::string* release_cards();
  inline void set_allocated_cards(::std::string* cards);

  // optional bytes outcards = 16;
  inline bool has_outcards() const;
  inline void clear_outcards();
  static const int kOutcardsFieldNumber = 16;
  inline const ::std::string& outcards() const;
  inline void set_outcards(const ::std::string& value);
  inline void set_outcards(const char* value);
  inline void set_outcards(const void* value, size_t size);
  inline ::std::string* mutable_outcards();
  inline ::std::string* release_outcards();
  inline void set_allocated_outcards(::std::string* outcards);

  // optional uint32 fa = 17;
  inline bool has_fa() const;
  inline void clear_fa();
  static const int kFaFieldNumber = 17;
  inline ::google::protobuf::uint32 fa() const;
  inline void set_fa(::google::protobuf::uint32 value);

  // optional uint32 piao = 18;
  inline bool has_piao() const;
  inline void clear_piao();
  static const int kPiaoFieldNumber = 18;
  inline ::google::protobuf::uint32 piao() const;
  inline void set_piao(::google::protobuf::uint32 value);

  // optional bool ready = 19;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 19;
  inline bool ready() const;
  inline void set_ready(bool value);

  // optional bool begin = 20;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 20;
  inline bool begin() const;
  inline void set_begin(bool value);

  // optional bool zhuang = 21;
  inline bool has_zhuang() const;
  inline void clear_zhuang();
  static const int kZhuangFieldNumber = 21;
  inline bool zhuang() const;
  inline void set_zhuang(bool value);

  // optional bool online = 22;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 22;
  inline bool online() const;
  inline void set_online(bool value);

  // @@protoc_insertion_point(class_scope:protocol.RoomUser)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_picid();
  inline void clear_has_picid();
  inline void set_has_picurl();
  inline void clear_has_picurl();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_lose();
  inline void clear_has_lose();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_vip();
  inline void clear_has_vip();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_cards();
  inline void clear_has_cards();
  inline void set_has_outcards();
  inline void clear_has_outcards();
  inline void set_has_fa();
  inline void clear_has_fa();
  inline void set_has_piao();
  inline void clear_has_piao();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_zhuang();
  inline void clear_has_zhuang();
  inline void set_has_online();
  inline void clear_has_online();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* username_;
  ::std::string* picurl_;
  ::google::protobuf::uint32 picid_;
  ::google::protobuf::uint32 sex_;
  ::std::string* ip_;
  ::google::protobuf::uint32 gold_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 win_;
  ::google::protobuf::uint32 lose_;
  ::google::protobuf::uint32 ping_;
  ::google::protobuf::uint32 vip_;
  ::google::protobuf::RepeatedPtrField< ::protocol::CPGCardData > cpgcard_;
  ::std::string* cards_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::uint32 fa_;
  ::std::string* outcards_;
  ::google::protobuf::uint32 piao_;
  bool ready_;
  bool begin_;
  bool zhuang_;
  bool online_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static RoomUser* default_instance_;
};
// -------------------------------------------------------------------

class TingCard : public ::google::protobuf::Message {
 public:
  TingCard();
  virtual ~TingCard();

  TingCard(const TingCard& from);

  inline TingCard& operator=(const TingCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TingCard& default_instance();

  void Swap(TingCard* other);

  // implements Message ----------------------------------------------

  TingCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TingCard& from);
  void MergeFrom(const TingCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 card = 1;
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 1;
  inline ::google::protobuf::uint32 card() const;
  inline void set_card(::google::protobuf::uint32 value);

  // optional bytes ting = 2;
  inline bool has_ting() const;
  inline void clear_ting();
  static const int kTingFieldNumber = 2;
  inline const ::std::string& ting() const;
  inline void set_ting(const ::std::string& value);
  inline void set_ting(const char* value);
  inline void set_ting(const void* value, size_t size);
  inline ::std::string* mutable_ting();
  inline ::std::string* release_ting();
  inline void set_allocated_ting(::std::string* ting);

  // @@protoc_insertion_point(class_scope:protocol.TingCard)
 private:
  inline void set_has_card();
  inline void clear_has_card();
  inline void set_has_ting();
  inline void clear_has_ting();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ting_;
  ::google::protobuf::uint32 card_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static TingCard* default_instance_;
};
// -------------------------------------------------------------------

class UserOver : public ::google::protobuf::Message {
 public:
  UserOver();
  virtual ~UserOver();

  UserOver(const UserOver& from);

  inline UserOver& operator=(const UserOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOver& default_instance();

  void Swap(UserOver* other);

  // implements Message ----------------------------------------------

  UserOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOver& from);
  void MergeFrom(const UserOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional uint32 position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional uint32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 total = 4;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 4;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional bytes cards = 5;
  inline bool has_cards() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 5;
  inline const ::std::string& cards() const;
  inline void set_cards(const ::std::string& value);
  inline void set_cards(const char* value);
  inline void set_cards(const void* value, size_t size);
  inline ::std::string* mutable_cards();
  inline ::std::string* release_cards();
  inline void set_allocated_cards(::std::string* cards);

  // @@protoc_insertion_point(class_scope:protocol.UserOver)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_cards();
  inline void clear_has_cards();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::uint32 score_;
  ::std::string* cards_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static UserOver* default_instance_;
};
// -------------------------------------------------------------------

class UserRound : public ::google::protobuf::Message {
 public:
  UserRound();
  virtual ~UserRound();

  UserRound(const UserRound& from);

  inline UserRound& operator=(const UserRound& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRound& default_instance();

  void Swap(UserRound* other);

  // implements Message ----------------------------------------------

  UserRound* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserRound& from);
  void MergeFrom(const UserRound& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional string pao = 3;
  inline bool has_pao() const;
  inline void clear_pao();
  static const int kPaoFieldNumber = 3;
  inline const ::std::string& pao() const;
  inline void set_pao(const ::std::string& value);
  inline void set_pao(const char* value);
  inline void set_pao(const char* value, size_t size);
  inline ::std::string* mutable_pao();
  inline ::std::string* release_pao();
  inline void set_allocated_pao(::std::string* pao);

  // optional string win = 4;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 4;
  inline const ::std::string& win() const;
  inline void set_win(const ::std::string& value);
  inline void set_win(const char* value);
  inline void set_win(const char* value, size_t size);
  inline ::std::string* mutable_win();
  inline ::std::string* release_win();
  inline void set_allocated_win(::std::string* win);

  // @@protoc_insertion_point(class_scope:protocol.UserRound)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_pao();
  inline void clear_has_pao();
  inline void set_has_win();
  inline void clear_has_win();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userid_;
  ::std::string* pao_;
  ::std::string* win_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static UserRound* default_instance_;
};
// -------------------------------------------------------------------

class CPing : public ::google::protobuf::Message {
 public:
  CPing();
  virtual ~CPing();

  CPing(const CPing& from);

  inline CPing& operator=(const CPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CPing& default_instance();

  void Swap(CPing* other);

  // implements Message ----------------------------------------------

  CPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CPing& from);
  void MergeFrom(const CPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 16387];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.CPing)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static CPing* default_instance_;
};
// -------------------------------------------------------------------

class SPing : public ::google::protobuf::Message {
 public:
  SPing();
  virtual ~SPing();

  SPing(const SPing& from);

  inline SPing& operator=(const SPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SPing& default_instance();

  void Swap(SPing* other);

  // implements Message ----------------------------------------------

  SPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SPing& from);
  void MergeFrom(const SPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 16387];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SPing)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Vo_2eproto();
  friend void protobuf_AssignDesc_Vo_2eproto();
  friend void protobuf_ShutdownFile_Vo_2eproto();

  void InitAsDefaultInstance();
  static SPing* default_instance_;
};
// ===================================================================


// ===================================================================

// UserBase

// optional string userid = 1;
inline bool UserBase::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBase::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBase::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBase::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UserBase::userid() const {
  return *userid_;
}
inline void UserBase::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserBase::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserBase::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBase::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* UserBase::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBase::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 2;
inline bool UserBase::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBase::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBase::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBase::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& UserBase::username() const {
  return *username_;
}
inline void UserBase::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserBase::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserBase::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBase::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* UserBase::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBase::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sex = 3 [default = 1];
inline bool UserBase::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBase::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBase::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBase::clear_sex() {
  sex_ = 1u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 UserBase::sex() const {
  return sex_;
}
inline void UserBase::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string ip = 4;
inline bool UserBase::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserBase::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserBase::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserBase::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& UserBase::ip() const {
  return *ip_;
}
inline void UserBase::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserBase::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void UserBase::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBase::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* UserBase::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBase::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool UserBase::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserBase::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserBase::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserBase::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserBase::address() const {
  return *address_;
}
inline void UserBase::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserBase::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserBase::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBase::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserBase::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBase::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gold = 6 [default = 4000];
inline bool UserBase::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserBase::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserBase::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserBase::clear_gold() {
  gold_ = 4000u;
  clear_has_gold();
}
inline ::google::protobuf::uint32 UserBase::gold() const {
  return gold_;
}
inline void UserBase::set_gold(::google::protobuf::uint32 value) {
  set_has_gold();
  gold_ = value;
}

// optional uint32 diamond = 7 [default = 8];
inline bool UserBase::has_diamond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserBase::set_has_diamond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserBase::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserBase::clear_diamond() {
  diamond_ = 8u;
  clear_has_diamond();
}
inline ::google::protobuf::uint32 UserBase::diamond() const {
  return diamond_;
}
inline void UserBase::set_diamond(::google::protobuf::uint32 value) {
  set_has_diamond();
  diamond_ = value;
}

// optional uint32 card = 8 [default = 1];
inline bool UserBase::has_card() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserBase::set_has_card() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserBase::clear_has_card() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserBase::clear_card() {
  card_ = 1u;
  clear_has_card();
}
inline ::google::protobuf::uint32 UserBase::card() const {
  return card_;
}
inline void UserBase::set_card(::google::protobuf::uint32 value) {
  set_has_card();
  card_ = value;
}

// optional uint32 picid = 9 [default = 1];
inline bool UserBase::has_picid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserBase::set_has_picid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserBase::clear_has_picid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserBase::clear_picid() {
  picid_ = 1u;
  clear_has_picid();
}
inline ::google::protobuf::uint32 UserBase::picid() const {
  return picid_;
}
inline void UserBase::set_picid(::google::protobuf::uint32 value) {
  set_has_picid();
  picid_ = value;
}

// optional string picurl = 10;
inline bool UserBase::has_picurl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserBase::set_has_picurl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserBase::clear_has_picurl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserBase::clear_picurl() {
  if (picurl_ != &::google::protobuf::internal::kEmptyString) {
    picurl_->clear();
  }
  clear_has_picurl();
}
inline const ::std::string& UserBase::picurl() const {
  return *picurl_;
}
inline void UserBase::set_picurl(const ::std::string& value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
}
inline void UserBase::set_picurl(const char* value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
}
inline void UserBase::set_picurl(const char* value, size_t size) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBase::mutable_picurl() {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  return picurl_;
}
inline ::std::string* UserBase::release_picurl() {
  clear_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picurl_;
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBase::set_allocated_picurl(::std::string* picurl) {
  if (picurl_ != &::google::protobuf::internal::kEmptyString) {
    delete picurl_;
  }
  if (picurl) {
    set_has_picurl();
    picurl_ = picurl;
  } else {
    clear_has_picurl();
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 11;
inline bool UserBase::has_phone() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserBase::set_has_phone() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserBase::clear_has_phone() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserBase::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& UserBase::phone() const {
  return *phone_;
}
inline void UserBase::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void UserBase::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void UserBase::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBase::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* UserBase::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBase::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 win = 12 [default = 0];
inline bool UserBase::has_win() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserBase::set_has_win() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserBase::clear_has_win() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserBase::clear_win() {
  win_ = 0u;
  clear_has_win();
}
inline ::google::protobuf::uint32 UserBase::win() const {
  return win_;
}
inline void UserBase::set_win(::google::protobuf::uint32 value) {
  set_has_win();
  win_ = value;
}

// optional uint32 lose = 13 [default = 0];
inline bool UserBase::has_lose() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserBase::set_has_lose() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserBase::clear_has_lose() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserBase::clear_lose() {
  lose_ = 0u;
  clear_has_lose();
}
inline ::google::protobuf::uint32 UserBase::lose() const {
  return lose_;
}
inline void UserBase::set_lose(::google::protobuf::uint32 value) {
  set_has_lose();
  lose_ = value;
}

// optional uint32 ping = 14 [default = 0];
inline bool UserBase::has_ping() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserBase::set_has_ping() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserBase::clear_has_ping() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserBase::clear_ping() {
  ping_ = 0u;
  clear_has_ping();
}
inline ::google::protobuf::uint32 UserBase::ping() const {
  return ping_;
}
inline void UserBase::set_ping(::google::protobuf::uint32 value) {
  set_has_ping();
  ping_ = value;
}

// optional uint32 vip = 15 [default = 0];
inline bool UserBase::has_vip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserBase::set_has_vip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserBase::clear_has_vip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserBase::clear_vip() {
  vip_ = 0u;
  clear_has_vip();
}
inline ::google::protobuf::uint32 UserBase::vip() const {
  return vip_;
}
inline void UserBase::set_vip(::google::protobuf::uint32 value) {
  set_has_vip();
  vip_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// optional .protocol.UserBase info = 1;
inline bool UserInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_info() {
  if (info_ != NULL) info_->::protocol::UserBase::Clear();
  clear_has_info();
}
inline const ::protocol::UserBase& UserInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::protocol::UserBase* UserInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::protocol::UserBase;
  return info_;
}
inline ::protocol::UserBase* UserInfo::release_info() {
  clear_has_info();
  ::protocol::UserBase* temp = info_;
  info_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_info(::protocol::UserBase* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 online = 2;
inline bool UserInfo::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_online() {
  online_ = 0u;
  clear_has_online();
}
inline ::google::protobuf::uint32 UserInfo::online() const {
  return online_;
}
inline void UserInfo::set_online(::google::protobuf::uint32 value) {
  set_has_online();
  online_ = value;
}

// -------------------------------------------------------------------

// Rank

// optional uint32 lv = 1;
inline bool Rank::has_lv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rank::set_has_lv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rank::clear_has_lv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rank::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 Rank::lv() const {
  return lv_;
}
inline void Rank::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional string uid = 2;
inline bool Rank::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rank::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rank::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rank::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Rank::uid() const {
  return *uid_;
}
inline void Rank::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Rank::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Rank::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Rank::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Rank::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Rank::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 3;
inline bool Rank::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rank::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rank::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rank::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Rank::type() const {
  return type_;
}
inline void Rank::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .protocol.UserBase info = 4;
inline bool Rank::has_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rank::set_has_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rank::clear_has_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rank::clear_info() {
  if (info_ != NULL) info_->::protocol::UserBase::Clear();
  clear_has_info();
}
inline const ::protocol::UserBase& Rank::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::protocol::UserBase* Rank::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::protocol::UserBase;
  return info_;
}
inline ::protocol::UserBase* Rank::release_info() {
  clear_has_info();
  ::protocol::UserBase* temp = info_;
  info_ = NULL;
  return temp;
}
inline void Rank::set_allocated_info(::protocol::UserBase* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// Prop

// optional uint32 id = 1;
inline bool Prop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prop::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Prop::id() const {
  return id_;
}
inline void Prop::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool Prop::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prop::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prop::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prop::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Prop::name() const {
  return *name_;
}
inline void Prop::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Prop::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Prop::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Prop::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Prop::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Prop::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Reward

// optional uint32 rid = 1;
inline bool Reward::has_rid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reward::set_has_rid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reward::clear_has_rid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reward::clear_rid() {
  rid_ = 0u;
  clear_has_rid();
}
inline ::google::protobuf::uint32 Reward::rid() const {
  return rid_;
}
inline void Reward::set_rid(::google::protobuf::uint32 value) {
  set_has_rid();
  rid_ = value;
}

// optional .protocol.Prop prop = 2;
inline bool Reward::has_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reward::set_has_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reward::clear_has_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reward::clear_prop() {
  if (prop_ != NULL) prop_->::protocol::Prop::Clear();
  clear_has_prop();
}
inline const ::protocol::Prop& Reward::prop() const {
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::protocol::Prop* Reward::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) prop_ = new ::protocol::Prop;
  return prop_;
}
inline ::protocol::Prop* Reward::release_prop() {
  clear_has_prop();
  ::protocol::Prop* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void Reward::set_allocated_prop(::protocol::Prop* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
}

// optional uint32 number = 3;
inline bool Reward::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reward::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reward::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reward::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Reward::number() const {
  return number_;
}
inline void Reward::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// ShopItem

// optional uint32 id = 1;
inline bool ShopItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopItem::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ShopItem::id() const {
  return id_;
}
inline void ShopItem::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .protocol.Reward prop = 2;
inline bool ShopItem::has_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopItem::set_has_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopItem::clear_has_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopItem::clear_prop() {
  if (prop_ != NULL) prop_->::protocol::Reward::Clear();
  clear_has_prop();
}
inline const ::protocol::Reward& ShopItem::prop() const {
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::protocol::Reward* ShopItem::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) prop_ = new ::protocol::Reward;
  return prop_;
}
inline ::protocol::Reward* ShopItem::release_prop() {
  clear_has_prop();
  ::protocol::Reward* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void ShopItem::set_allocated_prop(::protocol::Reward* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
}

// optional .protocol.Reward consume = 3;
inline bool ShopItem::has_consume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShopItem::set_has_consume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShopItem::clear_has_consume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShopItem::clear_consume() {
  if (consume_ != NULL) consume_->::protocol::Reward::Clear();
  clear_has_consume();
}
inline const ::protocol::Reward& ShopItem::consume() const {
  return consume_ != NULL ? *consume_ : *default_instance_->consume_;
}
inline ::protocol::Reward* ShopItem::mutable_consume() {
  set_has_consume();
  if (consume_ == NULL) consume_ = new ::protocol::Reward;
  return consume_;
}
inline ::protocol::Reward* ShopItem::release_consume() {
  clear_has_consume();
  ::protocol::Reward* temp = consume_;
  consume_ = NULL;
  return temp;
}
inline void ShopItem::set_allocated_consume(::protocol::Reward* consume) {
  delete consume_;
  consume_ = consume;
  if (consume) {
    set_has_consume();
  } else {
    clear_has_consume();
  }
}

// optional .protocol.Reward give = 4;
inline bool ShopItem::has_give() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShopItem::set_has_give() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShopItem::clear_has_give() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShopItem::clear_give() {
  if (give_ != NULL) give_->::protocol::Reward::Clear();
  clear_has_give();
}
inline const ::protocol::Reward& ShopItem::give() const {
  return give_ != NULL ? *give_ : *default_instance_->give_;
}
inline ::protocol::Reward* ShopItem::mutable_give() {
  set_has_give();
  if (give_ == NULL) give_ = new ::protocol::Reward;
  return give_;
}
inline ::protocol::Reward* ShopItem::release_give() {
  clear_has_give();
  ::protocol::Reward* temp = give_;
  give_ = NULL;
  return temp;
}
inline void ShopItem::set_allocated_give(::protocol::Reward* give) {
  delete give_;
  give_ = give;
  if (give) {
    set_has_give();
  } else {
    clear_has_give();
  }
}

// optional bool hot = 5;
inline bool ShopItem::has_hot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShopItem::set_has_hot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShopItem::clear_has_hot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShopItem::clear_hot() {
  hot_ = false;
  clear_has_hot();
}
inline bool ShopItem::hot() const {
  return hot_;
}
inline void ShopItem::set_hot(bool value) {
  set_has_hot();
  hot_ = value;
}

// -------------------------------------------------------------------

// Mail

// optional uint32 eid = 1;
inline bool Mail::has_eid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mail::set_has_eid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mail::clear_has_eid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mail::clear_eid() {
  eid_ = 0u;
  clear_has_eid();
}
inline ::google::protobuf::uint32 Mail::eid() const {
  return eid_;
}
inline void Mail::set_eid(::google::protobuf::uint32 value) {
  set_has_eid();
  eid_ = value;
}

// optional string title = 3;
inline bool Mail::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mail::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mail::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mail::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Mail::title() const {
  return *title_;
}
inline void Mail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Mail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Mail::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Mail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mail::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 4;
inline bool Mail::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mail::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mail::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mail::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Mail::content() const {
  return *content_;
}
inline void Mail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Mail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Mail::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Mail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mail::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 5;
inline bool Mail::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mail::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mail::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mail::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Mail::time() const {
  return *time_;
}
inline void Mail::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Mail::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Mail::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mail::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* Mail::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mail::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protocol.Reward rewardlist = 6;
inline int Mail::rewardlist_size() const {
  return rewardlist_.size();
}
inline void Mail::clear_rewardlist() {
  rewardlist_.Clear();
}
inline const ::protocol::Reward& Mail::rewardlist(int index) const {
  return rewardlist_.Get(index);
}
inline ::protocol::Reward* Mail::mutable_rewardlist(int index) {
  return rewardlist_.Mutable(index);
}
inline ::protocol::Reward* Mail::add_rewardlist() {
  return rewardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reward >&
Mail::rewardlist() const {
  return rewardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Reward >*
Mail::mutable_rewardlist() {
  return &rewardlist_;
}

// optional uint32 status = 7;
inline bool Mail::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mail::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Mail::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Mail::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 Mail::status() const {
  return status_;
}
inline void Mail::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// FriendNotice

// optional uint32 nid = 1;
inline bool FriendNotice::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendNotice::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendNotice::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendNotice::clear_nid() {
  nid_ = 0u;
  clear_has_nid();
}
inline ::google::protobuf::uint32 FriendNotice::nid() const {
  return nid_;
}
inline void FriendNotice::set_nid(::google::protobuf::uint32 value) {
  set_has_nid();
  nid_ = value;
}

// optional string content = 2;
inline bool FriendNotice::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendNotice::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendNotice::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendNotice::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& FriendNotice::content() const {
  return *content_;
}
inline void FriendNotice::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void FriendNotice::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void FriendNotice::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendNotice::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* FriendNotice::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendNotice::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uid = 3;
inline bool FriendNotice::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendNotice::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendNotice::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendNotice::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& FriendNotice::uid() const {
  return *uid_;
}
inline void FriendNotice::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void FriendNotice::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void FriendNotice::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendNotice::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* FriendNotice::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendNotice::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 4;
inline bool FriendNotice::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendNotice::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendNotice::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendNotice::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& FriendNotice::time() const {
  return *time_;
}
inline void FriendNotice::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void FriendNotice::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void FriendNotice::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendNotice::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* FriendNotice::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendNotice::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 5;
inline bool FriendNotice::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendNotice::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendNotice::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendNotice::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 FriendNotice::status() const {
  return status_;
}
inline void FriendNotice::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Friend

// optional .protocol.UserBase info = 1;
inline bool Friend::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Friend::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Friend::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Friend::clear_info() {
  if (info_ != NULL) info_->::protocol::UserBase::Clear();
  clear_has_info();
}
inline const ::protocol::UserBase& Friend::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::protocol::UserBase* Friend::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::protocol::UserBase;
  return info_;
}
inline ::protocol::UserBase* Friend::release_info() {
  clear_has_info();
  ::protocol::UserBase* temp = info_;
  info_ = NULL;
  return temp;
}
inline void Friend::set_allocated_info(::protocol::UserBase* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional bool online = 2;
inline bool Friend::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Friend::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Friend::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Friend::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool Friend::online() const {
  return online_;
}
inline void Friend::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional bool friend = 3;
inline bool Friend::has_friend_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Friend::set_has_friend_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Friend::clear_has_friend_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Friend::clear_friend_() {
  friend__ = false;
  clear_has_friend_();
}
inline bool Friend::friend_() const {
  return friend__;
}
inline void Friend::set_friend_(bool value) {
  set_has_friend_();
  friend__ = value;
}

// optional uint32 acttype = 4;
inline bool Friend::has_acttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Friend::set_has_acttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Friend::clear_has_acttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Friend::clear_acttype() {
  acttype_ = 0u;
  clear_has_acttype();
}
inline ::google::protobuf::uint32 Friend::acttype() const {
  return acttype_;
}
inline void Friend::set_acttype(::google::protobuf::uint32 value) {
  set_has_acttype();
  acttype_ = value;
}

// optional uint32 time = 5;
inline bool Friend::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Friend::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Friend::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Friend::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Friend::time() const {
  return time_;
}
inline void Friend::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Active

// optional uint32 id = 1;
inline bool Active::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Active::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Active::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Active::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Active::id() const {
  return id_;
}
inline void Active::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 type = 2;
inline bool Active::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Active::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Active::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Active::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Active::type() const {
  return type_;
}
inline void Active::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string url = 3;
inline bool Active::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Active::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Active::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Active::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Active::url() const {
  return *url_;
}
inline void Active::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Active::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Active::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Active::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Active::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Active::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Status

// optional uint32 count = 1;
inline bool Status::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 Status::count() const {
  return count_;
}
inline void Status::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 fcount = 2;
inline bool Status::has_fcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_fcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_fcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_fcount() {
  fcount_ = 0u;
  clear_has_fcount();
}
inline ::google::protobuf::uint32 Status::fcount() const {
  return fcount_;
}
inline void Status::set_fcount(::google::protobuf::uint32 value) {
  set_has_fcount();
  fcount_ = value;
}

// optional uint32 finished = 3;
inline bool Status::has_finished() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_finished() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_finished() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_finished() {
  finished_ = 0u;
  clear_has_finished();
}
inline ::google::protobuf::uint32 Status::finished() const {
  return finished_;
}
inline void Status::set_finished(::google::protobuf::uint32 value) {
  set_has_finished();
  finished_ = value;
}

// -------------------------------------------------------------------

// Task

// optional uint32 taskid = 1;
inline bool Task::has_taskid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_taskid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_taskid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_taskid() {
  taskid_ = 0u;
  clear_has_taskid();
}
inline ::google::protobuf::uint32 Task::taskid() const {
  return taskid_;
}
inline void Task::set_taskid(::google::protobuf::uint32 value) {
  set_has_taskid();
  taskid_ = value;
}

// optional string title = 2;
inline bool Task::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Task::title() const {
  return *title_;
}
inline void Task::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Task::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void Task::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* Task::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 3;
inline bool Task::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Task::content() const {
  return *content_;
}
inline void Task::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Task::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Task::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Task::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Task::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 4;
inline bool Task::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Task::type() const {
  return type_;
}
inline void Task::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated .protocol.Reward rewardlist = 5;
inline int Task::rewardlist_size() const {
  return rewardlist_.size();
}
inline void Task::clear_rewardlist() {
  rewardlist_.Clear();
}
inline const ::protocol::Reward& Task::rewardlist(int index) const {
  return rewardlist_.Get(index);
}
inline ::protocol::Reward* Task::mutable_rewardlist(int index) {
  return rewardlist_.Mutable(index);
}
inline ::protocol::Reward* Task::add_rewardlist() {
  return rewardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reward >&
Task::rewardlist() const {
  return rewardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Reward >*
Task::mutable_rewardlist() {
  return &rewardlist_;
}

// optional .protocol.Status status = 6;
inline bool Task::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Task::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Task::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Task::clear_status() {
  if (status_ != NULL) status_->::protocol::Status::Clear();
  clear_has_status();
}
inline const ::protocol::Status& Task::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::protocol::Status* Task::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::protocol::Status;
  return status_;
}
inline ::protocol::Status* Task::release_status() {
  clear_has_status();
  ::protocol::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Task::set_allocated_status(::protocol::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// ExAward

// optional uint32 eid = 1;
inline bool ExAward::has_eid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExAward::set_has_eid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExAward::clear_has_eid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExAward::clear_eid() {
  eid_ = 0u;
  clear_has_eid();
}
inline ::google::protobuf::uint32 ExAward::eid() const {
  return eid_;
}
inline void ExAward::set_eid(::google::protobuf::uint32 value) {
  set_has_eid();
  eid_ = value;
}

// optional string title = 2;
inline bool ExAward::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExAward::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExAward::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExAward::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ExAward::title() const {
  return *title_;
}
inline void ExAward::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ExAward::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ExAward::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExAward::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* ExAward::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExAward::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocol.Reward award = 3;
inline bool ExAward::has_award() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExAward::set_has_award() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExAward::clear_has_award() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExAward::clear_award() {
  if (award_ != NULL) award_->::protocol::Reward::Clear();
  clear_has_award();
}
inline const ::protocol::Reward& ExAward::award() const {
  return award_ != NULL ? *award_ : *default_instance_->award_;
}
inline ::protocol::Reward* ExAward::mutable_award() {
  set_has_award();
  if (award_ == NULL) award_ = new ::protocol::Reward;
  return award_;
}
inline ::protocol::Reward* ExAward::release_award() {
  clear_has_award();
  ::protocol::Reward* temp = award_;
  award_ = NULL;
  return temp;
}
inline void ExAward::set_allocated_award(::protocol::Reward* award) {
  delete award_;
  award_ = award;
  if (award) {
    set_has_award();
  } else {
    clear_has_award();
  }
}

// optional .protocol.Reward buy = 4;
inline bool ExAward::has_buy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExAward::set_has_buy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExAward::clear_has_buy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExAward::clear_buy() {
  if (buy_ != NULL) buy_->::protocol::Reward::Clear();
  clear_has_buy();
}
inline const ::protocol::Reward& ExAward::buy() const {
  return buy_ != NULL ? *buy_ : *default_instance_->buy_;
}
inline ::protocol::Reward* ExAward::mutable_buy() {
  set_has_buy();
  if (buy_ == NULL) buy_ = new ::protocol::Reward;
  return buy_;
}
inline ::protocol::Reward* ExAward::release_buy() {
  clear_has_buy();
  ::protocol::Reward* temp = buy_;
  buy_ = NULL;
  return temp;
}
inline void ExAward::set_allocated_buy(::protocol::Reward* buy) {
  delete buy_;
  buy_ = buy;
  if (buy) {
    set_has_buy();
  } else {
    clear_has_buy();
  }
}

// -------------------------------------------------------------------

// ExRecord

// optional uint32 eid = 1;
inline bool ExRecord::has_eid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExRecord::set_has_eid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExRecord::clear_has_eid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExRecord::clear_eid() {
  eid_ = 0u;
  clear_has_eid();
}
inline ::google::protobuf::uint32 ExRecord::eid() const {
  return eid_;
}
inline void ExRecord::set_eid(::google::protobuf::uint32 value) {
  set_has_eid();
  eid_ = value;
}

// optional string title = 2;
inline bool ExRecord::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExRecord::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExRecord::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExRecord::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ExRecord::title() const {
  return *title_;
}
inline void ExRecord::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ExRecord::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ExRecord::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExRecord::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* ExRecord::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExRecord::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string orderid = 3;
inline bool ExRecord::has_orderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExRecord::set_has_orderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExRecord::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExRecord::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& ExRecord::orderid() const {
  return *orderid_;
}
inline void ExRecord::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void ExRecord::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void ExRecord::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExRecord::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* ExRecord::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExRecord::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 4;
inline bool ExRecord::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExRecord::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExRecord::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExRecord::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& ExRecord::time() const {
  return *time_;
}
inline void ExRecord::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void ExRecord::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void ExRecord::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExRecord::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* ExRecord::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExRecord::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 status = 5;
inline bool ExRecord::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExRecord::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExRecord::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExRecord::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ExRecord::status() const {
  return status_;
}
inline void ExRecord::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SignAward

// optional uint32 id = 1;
inline bool SignAward::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignAward::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignAward::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignAward::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SignAward::id() const {
  return id_;
}
inline void SignAward::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 day = 2;
inline bool SignAward::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignAward::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignAward::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignAward::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 SignAward::day() const {
  return day_;
}
inline void SignAward::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional .protocol.Reward reward = 3;
inline bool SignAward::has_reward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignAward::set_has_reward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignAward::clear_has_reward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignAward::clear_reward() {
  if (reward_ != NULL) reward_->::protocol::Reward::Clear();
  clear_has_reward();
}
inline const ::protocol::Reward& SignAward::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::protocol::Reward* SignAward::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::protocol::Reward;
  return reward_;
}
inline ::protocol::Reward* SignAward::release_reward() {
  clear_has_reward();
  ::protocol::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline void SignAward::set_allocated_reward(::protocol::Reward* reward) {
  delete reward_;
  reward_ = reward;
  if (reward) {
    set_has_reward();
  } else {
    clear_has_reward();
  }
}

// -------------------------------------------------------------------

// SignZhuan

// optional uint32 index = 1;
inline bool SignZhuan::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignZhuan::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignZhuan::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignZhuan::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SignZhuan::index() const {
  return index_;
}
inline void SignZhuan::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .protocol.Reward reward = 2;
inline bool SignZhuan::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignZhuan::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignZhuan::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignZhuan::clear_reward() {
  if (reward_ != NULL) reward_->::protocol::Reward::Clear();
  clear_has_reward();
}
inline const ::protocol::Reward& SignZhuan::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::protocol::Reward* SignZhuan::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::protocol::Reward;
  return reward_;
}
inline ::protocol::Reward* SignZhuan::release_reward() {
  clear_has_reward();
  ::protocol::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline void SignZhuan::set_allocated_reward(::protocol::Reward* reward) {
  delete reward_;
  reward_ = reward;
  if (reward) {
    set_has_reward();
  } else {
    clear_has_reward();
  }
}

// -------------------------------------------------------------------

// PayRecord

// optional string userid = 1;
inline bool PayRecord::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayRecord::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayRecord::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayRecord::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& PayRecord::userid() const {
  return *userid_;
}
inline void PayRecord::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void PayRecord::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void PayRecord::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* PayRecord::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string attach = 2;
inline bool PayRecord::has_attach() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayRecord::set_has_attach() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayRecord::clear_has_attach() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayRecord::clear_attach() {
  if (attach_ != &::google::protobuf::internal::kEmptyString) {
    attach_->clear();
  }
  clear_has_attach();
}
inline const ::std::string& PayRecord::attach() const {
  return *attach_;
}
inline void PayRecord::set_attach(const ::std::string& value) {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  attach_->assign(value);
}
inline void PayRecord::set_attach(const char* value) {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  attach_->assign(value);
}
inline void PayRecord::set_attach(const char* value, size_t size) {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  attach_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_attach() {
  set_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    attach_ = new ::std::string;
  }
  return attach_;
}
inline ::std::string* PayRecord::release_attach() {
  clear_has_attach();
  if (attach_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attach_;
    attach_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_attach(::std::string* attach) {
  if (attach_ != &::google::protobuf::internal::kEmptyString) {
    delete attach_;
  }
  if (attach) {
    set_has_attach();
    attach_ = attach;
  } else {
    clear_has_attach();
    attach_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string out_trade_no = 3;
inline bool PayRecord::has_out_trade_no() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayRecord::set_has_out_trade_no() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayRecord::clear_has_out_trade_no() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayRecord::clear_out_trade_no() {
  if (out_trade_no_ != &::google::protobuf::internal::kEmptyString) {
    out_trade_no_->clear();
  }
  clear_has_out_trade_no();
}
inline const ::std::string& PayRecord::out_trade_no() const {
  return *out_trade_no_;
}
inline void PayRecord::set_out_trade_no(const ::std::string& value) {
  set_has_out_trade_no();
  if (out_trade_no_ == &::google::protobuf::internal::kEmptyString) {
    out_trade_no_ = new ::std::string;
  }
  out_trade_no_->assign(value);
}
inline void PayRecord::set_out_trade_no(const char* value) {
  set_has_out_trade_no();
  if (out_trade_no_ == &::google::protobuf::internal::kEmptyString) {
    out_trade_no_ = new ::std::string;
  }
  out_trade_no_->assign(value);
}
inline void PayRecord::set_out_trade_no(const char* value, size_t size) {
  set_has_out_trade_no();
  if (out_trade_no_ == &::google::protobuf::internal::kEmptyString) {
    out_trade_no_ = new ::std::string;
  }
  out_trade_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_out_trade_no() {
  set_has_out_trade_no();
  if (out_trade_no_ == &::google::protobuf::internal::kEmptyString) {
    out_trade_no_ = new ::std::string;
  }
  return out_trade_no_;
}
inline ::std::string* PayRecord::release_out_trade_no() {
  clear_has_out_trade_no();
  if (out_trade_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = out_trade_no_;
    out_trade_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_out_trade_no(::std::string* out_trade_no) {
  if (out_trade_no_ != &::google::protobuf::internal::kEmptyString) {
    delete out_trade_no_;
  }
  if (out_trade_no) {
    set_has_out_trade_no();
    out_trade_no_ = out_trade_no;
  } else {
    clear_has_out_trade_no();
    out_trade_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time_start = 4;
inline bool PayRecord::has_time_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PayRecord::set_has_time_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PayRecord::clear_has_time_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PayRecord::clear_time_start() {
  if (time_start_ != &::google::protobuf::internal::kEmptyString) {
    time_start_->clear();
  }
  clear_has_time_start();
}
inline const ::std::string& PayRecord::time_start() const {
  return *time_start_;
}
inline void PayRecord::set_time_start(const ::std::string& value) {
  set_has_time_start();
  if (time_start_ == &::google::protobuf::internal::kEmptyString) {
    time_start_ = new ::std::string;
  }
  time_start_->assign(value);
}
inline void PayRecord::set_time_start(const char* value) {
  set_has_time_start();
  if (time_start_ == &::google::protobuf::internal::kEmptyString) {
    time_start_ = new ::std::string;
  }
  time_start_->assign(value);
}
inline void PayRecord::set_time_start(const char* value, size_t size) {
  set_has_time_start();
  if (time_start_ == &::google::protobuf::internal::kEmptyString) {
    time_start_ = new ::std::string;
  }
  time_start_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_time_start() {
  set_has_time_start();
  if (time_start_ == &::google::protobuf::internal::kEmptyString) {
    time_start_ = new ::std::string;
  }
  return time_start_;
}
inline ::std::string* PayRecord::release_time_start() {
  clear_has_time_start();
  if (time_start_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_start_;
    time_start_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_time_start(::std::string* time_start) {
  if (time_start_ != &::google::protobuf::internal::kEmptyString) {
    delete time_start_;
  }
  if (time_start) {
    set_has_time_start();
    time_start_ = time_start;
  } else {
    clear_has_time_start();
    time_start_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time_expire = 5;
inline bool PayRecord::has_time_expire() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PayRecord::set_has_time_expire() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PayRecord::clear_has_time_expire() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PayRecord::clear_time_expire() {
  if (time_expire_ != &::google::protobuf::internal::kEmptyString) {
    time_expire_->clear();
  }
  clear_has_time_expire();
}
inline const ::std::string& PayRecord::time_expire() const {
  return *time_expire_;
}
inline void PayRecord::set_time_expire(const ::std::string& value) {
  set_has_time_expire();
  if (time_expire_ == &::google::protobuf::internal::kEmptyString) {
    time_expire_ = new ::std::string;
  }
  time_expire_->assign(value);
}
inline void PayRecord::set_time_expire(const char* value) {
  set_has_time_expire();
  if (time_expire_ == &::google::protobuf::internal::kEmptyString) {
    time_expire_ = new ::std::string;
  }
  time_expire_->assign(value);
}
inline void PayRecord::set_time_expire(const char* value, size_t size) {
  set_has_time_expire();
  if (time_expire_ == &::google::protobuf::internal::kEmptyString) {
    time_expire_ = new ::std::string;
  }
  time_expire_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_time_expire() {
  set_has_time_expire();
  if (time_expire_ == &::google::protobuf::internal::kEmptyString) {
    time_expire_ = new ::std::string;
  }
  return time_expire_;
}
inline ::std::string* PayRecord::release_time_expire() {
  clear_has_time_expire();
  if (time_expire_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_expire_;
    time_expire_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_time_expire(::std::string* time_expire) {
  if (time_expire_ != &::google::protobuf::internal::kEmptyString) {
    delete time_expire_;
  }
  if (time_expire) {
    set_has_time_expire();
    time_expire_ = time_expire;
  } else {
    clear_has_time_expire();
    time_expire_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string prepay_id = 6;
inline bool PayRecord::has_prepay_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PayRecord::set_has_prepay_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PayRecord::clear_has_prepay_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PayRecord::clear_prepay_id() {
  if (prepay_id_ != &::google::protobuf::internal::kEmptyString) {
    prepay_id_->clear();
  }
  clear_has_prepay_id();
}
inline const ::std::string& PayRecord::prepay_id() const {
  return *prepay_id_;
}
inline void PayRecord::set_prepay_id(const ::std::string& value) {
  set_has_prepay_id();
  if (prepay_id_ == &::google::protobuf::internal::kEmptyString) {
    prepay_id_ = new ::std::string;
  }
  prepay_id_->assign(value);
}
inline void PayRecord::set_prepay_id(const char* value) {
  set_has_prepay_id();
  if (prepay_id_ == &::google::protobuf::internal::kEmptyString) {
    prepay_id_ = new ::std::string;
  }
  prepay_id_->assign(value);
}
inline void PayRecord::set_prepay_id(const char* value, size_t size) {
  set_has_prepay_id();
  if (prepay_id_ == &::google::protobuf::internal::kEmptyString) {
    prepay_id_ = new ::std::string;
  }
  prepay_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_prepay_id() {
  set_has_prepay_id();
  if (prepay_id_ == &::google::protobuf::internal::kEmptyString) {
    prepay_id_ = new ::std::string;
  }
  return prepay_id_;
}
inline ::std::string* PayRecord::release_prepay_id() {
  clear_has_prepay_id();
  if (prepay_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prepay_id_;
    prepay_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_prepay_id(::std::string* prepay_id) {
  if (prepay_id_ != &::google::protobuf::internal::kEmptyString) {
    delete prepay_id_;
  }
  if (prepay_id) {
    set_has_prepay_id();
    prepay_id_ = prepay_id;
  } else {
    clear_has_prepay_id();
    prepay_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string body = 7;
inline bool PayRecord::has_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PayRecord::set_has_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PayRecord::clear_has_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PayRecord::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& PayRecord::body() const {
  return *body_;
}
inline void PayRecord::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void PayRecord::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void PayRecord::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* PayRecord::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string total_fee = 8;
inline bool PayRecord::has_total_fee() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PayRecord::set_has_total_fee() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PayRecord::clear_has_total_fee() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PayRecord::clear_total_fee() {
  if (total_fee_ != &::google::protobuf::internal::kEmptyString) {
    total_fee_->clear();
  }
  clear_has_total_fee();
}
inline const ::std::string& PayRecord::total_fee() const {
  return *total_fee_;
}
inline void PayRecord::set_total_fee(const ::std::string& value) {
  set_has_total_fee();
  if (total_fee_ == &::google::protobuf::internal::kEmptyString) {
    total_fee_ = new ::std::string;
  }
  total_fee_->assign(value);
}
inline void PayRecord::set_total_fee(const char* value) {
  set_has_total_fee();
  if (total_fee_ == &::google::protobuf::internal::kEmptyString) {
    total_fee_ = new ::std::string;
  }
  total_fee_->assign(value);
}
inline void PayRecord::set_total_fee(const char* value, size_t size) {
  set_has_total_fee();
  if (total_fee_ == &::google::protobuf::internal::kEmptyString) {
    total_fee_ = new ::std::string;
  }
  total_fee_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_total_fee() {
  set_has_total_fee();
  if (total_fee_ == &::google::protobuf::internal::kEmptyString) {
    total_fee_ = new ::std::string;
  }
  return total_fee_;
}
inline ::std::string* PayRecord::release_total_fee() {
  clear_has_total_fee();
  if (total_fee_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = total_fee_;
    total_fee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_total_fee(::std::string* total_fee) {
  if (total_fee_ != &::google::protobuf::internal::kEmptyString) {
    delete total_fee_;
  }
  if (total_fee) {
    set_has_total_fee();
    total_fee_ = total_fee;
  } else {
    clear_has_total_fee();
    total_fee_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string spbill_create_ip = 9;
inline bool PayRecord::has_spbill_create_ip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PayRecord::set_has_spbill_create_ip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PayRecord::clear_has_spbill_create_ip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PayRecord::clear_spbill_create_ip() {
  if (spbill_create_ip_ != &::google::protobuf::internal::kEmptyString) {
    spbill_create_ip_->clear();
  }
  clear_has_spbill_create_ip();
}
inline const ::std::string& PayRecord::spbill_create_ip() const {
  return *spbill_create_ip_;
}
inline void PayRecord::set_spbill_create_ip(const ::std::string& value) {
  set_has_spbill_create_ip();
  if (spbill_create_ip_ == &::google::protobuf::internal::kEmptyString) {
    spbill_create_ip_ = new ::std::string;
  }
  spbill_create_ip_->assign(value);
}
inline void PayRecord::set_spbill_create_ip(const char* value) {
  set_has_spbill_create_ip();
  if (spbill_create_ip_ == &::google::protobuf::internal::kEmptyString) {
    spbill_create_ip_ = new ::std::string;
  }
  spbill_create_ip_->assign(value);
}
inline void PayRecord::set_spbill_create_ip(const char* value, size_t size) {
  set_has_spbill_create_ip();
  if (spbill_create_ip_ == &::google::protobuf::internal::kEmptyString) {
    spbill_create_ip_ = new ::std::string;
  }
  spbill_create_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PayRecord::mutable_spbill_create_ip() {
  set_has_spbill_create_ip();
  if (spbill_create_ip_ == &::google::protobuf::internal::kEmptyString) {
    spbill_create_ip_ = new ::std::string;
  }
  return spbill_create_ip_;
}
inline ::std::string* PayRecord::release_spbill_create_ip() {
  clear_has_spbill_create_ip();
  if (spbill_create_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spbill_create_ip_;
    spbill_create_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PayRecord::set_allocated_spbill_create_ip(::std::string* spbill_create_ip) {
  if (spbill_create_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete spbill_create_ip_;
  }
  if (spbill_create_ip) {
    set_has_spbill_create_ip();
    spbill_create_ip_ = spbill_create_ip;
  } else {
    clear_has_spbill_create_ip();
    spbill_create_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomData

// optional uint32 type = 1;
inline bool RoomData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 RoomData::type() const {
  return type_;
}
inline void RoomData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 ante = 2;
inline bool RoomData::has_ante() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomData::set_has_ante() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomData::clear_has_ante() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomData::clear_ante() {
  ante_ = 0u;
  clear_has_ante();
}
inline ::google::protobuf::uint32 RoomData::ante() const {
  return ante_;
}
inline void RoomData::set_ante(::google::protobuf::uint32 value) {
  set_has_ante();
  ante_ = value;
}

// optional uint32 round = 3;
inline bool RoomData::has_round() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomData::set_has_round() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomData::clear_has_round() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomData::clear_round() {
  round_ = 0u;
  clear_has_round();
}
inline ::google::protobuf::uint32 RoomData::round() const {
  return round_;
}
inline void RoomData::set_round(::google::protobuf::uint32 value) {
  set_has_round();
  round_ = value;
}

// optional uint32 bao = 4;
inline bool RoomData::has_bao() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomData::set_has_bao() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomData::clear_has_bao() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomData::clear_bao() {
  bao_ = 0u;
  clear_has_bao();
}
inline ::google::protobuf::uint32 RoomData::bao() const {
  return bao_;
}
inline void RoomData::set_bao(::google::protobuf::uint32 value) {
  set_has_bao();
  bao_ = value;
}

// optional uint32 bang = 5;
inline bool RoomData::has_bang() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomData::set_has_bang() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomData::clear_has_bang() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomData::clear_bang() {
  bang_ = 0u;
  clear_has_bang();
}
inline ::google::protobuf::uint32 RoomData::bang() const {
  return bang_;
}
inline void RoomData::set_bang(::google::protobuf::uint32 value) {
  set_has_bang();
  bang_ = value;
}

// optional string roomid = 6;
inline bool RoomData::has_roomid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomData::set_has_roomid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomData::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomData::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& RoomData::roomid() const {
  return *roomid_;
}
inline void RoomData::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void RoomData::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void RoomData::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomData::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* RoomData::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomData::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roomtype = 7;
inline bool RoomData::has_roomtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomData::set_has_roomtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomData::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomData::clear_roomtype() {
  if (roomtype_ != &::google::protobuf::internal::kEmptyString) {
    roomtype_->clear();
  }
  clear_has_roomtype();
}
inline const ::std::string& RoomData::roomtype() const {
  return *roomtype_;
}
inline void RoomData::set_roomtype(const ::std::string& value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
}
inline void RoomData::set_roomtype(const char* value) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(value);
}
inline void RoomData::set_roomtype(const char* value, size_t size) {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  roomtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomData::mutable_roomtype() {
  set_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    roomtype_ = new ::std::string;
  }
  return roomtype_;
}
inline ::std::string* RoomData::release_roomtype() {
  clear_has_roomtype();
  if (roomtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomtype_;
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomData::set_allocated_roomtype(::std::string* roomtype) {
  if (roomtype_ != &::google::protobuf::internal::kEmptyString) {
    delete roomtype_;
  }
  if (roomtype) {
    set_has_roomtype();
    roomtype_ = roomtype;
  } else {
    clear_has_roomtype();
    roomtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uid = 8;
inline bool RoomData::has_uid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomData::set_has_uid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomData::clear_has_uid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomData::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RoomData::uid() const {
  return *uid_;
}
inline void RoomData::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RoomData::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RoomData::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomData::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RoomData::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomData::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CPGCardData

// optional uint32 type = 1;
inline bool CPGCardData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPGCardData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPGCardData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPGCardData::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CPGCardData::type() const {
  return type_;
}
inline void CPGCardData::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes cards = 2;
inline bool CPGCardData::has_cards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CPGCardData::set_has_cards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CPGCardData::clear_has_cards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CPGCardData::clear_cards() {
  if (cards_ != &::google::protobuf::internal::kEmptyString) {
    cards_->clear();
  }
  clear_has_cards();
}
inline const ::std::string& CPGCardData::cards() const {
  return *cards_;
}
inline void CPGCardData::set_cards(const ::std::string& value) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(value);
}
inline void CPGCardData::set_cards(const char* value) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(value);
}
inline void CPGCardData::set_cards(const void* value, size_t size) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CPGCardData::mutable_cards() {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  return cards_;
}
inline ::std::string* CPGCardData::release_cards() {
  clear_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cards_;
    cards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CPGCardData::set_allocated_cards(::std::string* cards) {
  if (cards_ != &::google::protobuf::internal::kEmptyString) {
    delete cards_;
  }
  if (cards) {
    set_has_cards();
    cards_ = cards;
  } else {
    clear_has_cards();
    cards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 index = 3;
inline bool CPGCardData::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CPGCardData::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CPGCardData::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CPGCardData::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 CPGCardData::index() const {
  return index_;
}
inline void CPGCardData::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 bei = 4;
inline bool CPGCardData::has_bei() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CPGCardData::set_has_bei() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CPGCardData::clear_has_bei() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CPGCardData::clear_bei() {
  bei_ = 0u;
  clear_has_bei();
}
inline ::google::protobuf::uint32 CPGCardData::bei() const {
  return bei_;
}
inline void CPGCardData::set_bei(::google::protobuf::uint32 value) {
  set_has_bei();
  bei_ = value;
}

// -------------------------------------------------------------------

// RoomUser

// optional string userid = 1;
inline bool RoomUser::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomUser::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomUser::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomUser::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& RoomUser::userid() const {
  return *userid_;
}
inline void RoomUser::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RoomUser::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void RoomUser::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomUser::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* RoomUser::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomUser::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 2;
inline bool RoomUser::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomUser::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomUser::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& RoomUser::username() const {
  return *username_;
}
inline void RoomUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void RoomUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void RoomUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* RoomUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 picid = 3;
inline bool RoomUser::has_picid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomUser::set_has_picid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomUser::clear_has_picid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomUser::clear_picid() {
  picid_ = 0u;
  clear_has_picid();
}
inline ::google::protobuf::uint32 RoomUser::picid() const {
  return picid_;
}
inline void RoomUser::set_picid(::google::protobuf::uint32 value) {
  set_has_picid();
  picid_ = value;
}

// optional string picurl = 4;
inline bool RoomUser::has_picurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomUser::set_has_picurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomUser::clear_has_picurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomUser::clear_picurl() {
  if (picurl_ != &::google::protobuf::internal::kEmptyString) {
    picurl_->clear();
  }
  clear_has_picurl();
}
inline const ::std::string& RoomUser::picurl() const {
  return *picurl_;
}
inline void RoomUser::set_picurl(const ::std::string& value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
}
inline void RoomUser::set_picurl(const char* value) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(value);
}
inline void RoomUser::set_picurl(const char* value, size_t size) {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  picurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomUser::mutable_picurl() {
  set_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    picurl_ = new ::std::string;
  }
  return picurl_;
}
inline ::std::string* RoomUser::release_picurl() {
  clear_has_picurl();
  if (picurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picurl_;
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomUser::set_allocated_picurl(::std::string* picurl) {
  if (picurl_ != &::google::protobuf::internal::kEmptyString) {
    delete picurl_;
  }
  if (picurl) {
    set_has_picurl();
    picurl_ = picurl;
  } else {
    clear_has_picurl();
    picurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sex = 5;
inline bool RoomUser::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomUser::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomUser::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomUser::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 RoomUser::sex() const {
  return sex_;
}
inline void RoomUser::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string ip = 6;
inline bool RoomUser::has_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomUser::set_has_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomUser::clear_has_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomUser::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RoomUser::ip() const {
  return *ip_;
}
inline void RoomUser::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RoomUser::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RoomUser::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomUser::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RoomUser::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomUser::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gold = 7;
inline bool RoomUser::has_gold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomUser::set_has_gold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomUser::clear_has_gold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomUser::clear_gold() {
  gold_ = 0u;
  clear_has_gold();
}
inline ::google::protobuf::uint32 RoomUser::gold() const {
  return gold_;
}
inline void RoomUser::set_gold(::google::protobuf::uint32 value) {
  set_has_gold();
  gold_ = value;
}

// optional uint32 score = 8;
inline bool RoomUser::has_score() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomUser::set_has_score() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomUser::clear_has_score() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomUser::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 RoomUser::score() const {
  return score_;
}
inline void RoomUser::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 win = 9;
inline bool RoomUser::has_win() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomUser::set_has_win() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomUser::clear_has_win() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomUser::clear_win() {
  win_ = 0u;
  clear_has_win();
}
inline ::google::protobuf::uint32 RoomUser::win() const {
  return win_;
}
inline void RoomUser::set_win(::google::protobuf::uint32 value) {
  set_has_win();
  win_ = value;
}

// optional uint32 lose = 10;
inline bool RoomUser::has_lose() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomUser::set_has_lose() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomUser::clear_has_lose() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomUser::clear_lose() {
  lose_ = 0u;
  clear_has_lose();
}
inline ::google::protobuf::uint32 RoomUser::lose() const {
  return lose_;
}
inline void RoomUser::set_lose(::google::protobuf::uint32 value) {
  set_has_lose();
  lose_ = value;
}

// optional uint32 ping = 11;
inline bool RoomUser::has_ping() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomUser::set_has_ping() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomUser::clear_has_ping() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomUser::clear_ping() {
  ping_ = 0u;
  clear_has_ping();
}
inline ::google::protobuf::uint32 RoomUser::ping() const {
  return ping_;
}
inline void RoomUser::set_ping(::google::protobuf::uint32 value) {
  set_has_ping();
  ping_ = value;
}

// optional uint32 vip = 12;
inline bool RoomUser::has_vip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RoomUser::set_has_vip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RoomUser::clear_has_vip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RoomUser::clear_vip() {
  vip_ = 0u;
  clear_has_vip();
}
inline ::google::protobuf::uint32 RoomUser::vip() const {
  return vip_;
}
inline void RoomUser::set_vip(::google::protobuf::uint32 value) {
  set_has_vip();
  vip_ = value;
}

// repeated .protocol.CPGCardData cpgcard = 13;
inline int RoomUser::cpgcard_size() const {
  return cpgcard_.size();
}
inline void RoomUser::clear_cpgcard() {
  cpgcard_.Clear();
}
inline const ::protocol::CPGCardData& RoomUser::cpgcard(int index) const {
  return cpgcard_.Get(index);
}
inline ::protocol::CPGCardData* RoomUser::mutable_cpgcard(int index) {
  return cpgcard_.Mutable(index);
}
inline ::protocol::CPGCardData* RoomUser::add_cpgcard() {
  return cpgcard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::CPGCardData >&
RoomUser::cpgcard() const {
  return cpgcard_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::CPGCardData >*
RoomUser::mutable_cpgcard() {
  return &cpgcard_;
}

// optional uint32 position = 14;
inline bool RoomUser::has_position() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RoomUser::set_has_position() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RoomUser::clear_has_position() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RoomUser::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 RoomUser::position() const {
  return position_;
}
inline void RoomUser::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional bytes cards = 15;
inline bool RoomUser::has_cards() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RoomUser::set_has_cards() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RoomUser::clear_has_cards() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RoomUser::clear_cards() {
  if (cards_ != &::google::protobuf::internal::kEmptyString) {
    cards_->clear();
  }
  clear_has_cards();
}
inline const ::std::string& RoomUser::cards() const {
  return *cards_;
}
inline void RoomUser::set_cards(const ::std::string& value) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(value);
}
inline void RoomUser::set_cards(const char* value) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(value);
}
inline void RoomUser::set_cards(const void* value, size_t size) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomUser::mutable_cards() {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  return cards_;
}
inline ::std::string* RoomUser::release_cards() {
  clear_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cards_;
    cards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomUser::set_allocated_cards(::std::string* cards) {
  if (cards_ != &::google::protobuf::internal::kEmptyString) {
    delete cards_;
  }
  if (cards) {
    set_has_cards();
    cards_ = cards;
  } else {
    clear_has_cards();
    cards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes outcards = 16;
inline bool RoomUser::has_outcards() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RoomUser::set_has_outcards() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RoomUser::clear_has_outcards() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RoomUser::clear_outcards() {
  if (outcards_ != &::google::protobuf::internal::kEmptyString) {
    outcards_->clear();
  }
  clear_has_outcards();
}
inline const ::std::string& RoomUser::outcards() const {
  return *outcards_;
}
inline void RoomUser::set_outcards(const ::std::string& value) {
  set_has_outcards();
  if (outcards_ == &::google::protobuf::internal::kEmptyString) {
    outcards_ = new ::std::string;
  }
  outcards_->assign(value);
}
inline void RoomUser::set_outcards(const char* value) {
  set_has_outcards();
  if (outcards_ == &::google::protobuf::internal::kEmptyString) {
    outcards_ = new ::std::string;
  }
  outcards_->assign(value);
}
inline void RoomUser::set_outcards(const void* value, size_t size) {
  set_has_outcards();
  if (outcards_ == &::google::protobuf::internal::kEmptyString) {
    outcards_ = new ::std::string;
  }
  outcards_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomUser::mutable_outcards() {
  set_has_outcards();
  if (outcards_ == &::google::protobuf::internal::kEmptyString) {
    outcards_ = new ::std::string;
  }
  return outcards_;
}
inline ::std::string* RoomUser::release_outcards() {
  clear_has_outcards();
  if (outcards_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outcards_;
    outcards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomUser::set_allocated_outcards(::std::string* outcards) {
  if (outcards_ != &::google::protobuf::internal::kEmptyString) {
    delete outcards_;
  }
  if (outcards) {
    set_has_outcards();
    outcards_ = outcards;
  } else {
    clear_has_outcards();
    outcards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fa = 17;
inline bool RoomUser::has_fa() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RoomUser::set_has_fa() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RoomUser::clear_has_fa() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RoomUser::clear_fa() {
  fa_ = 0u;
  clear_has_fa();
}
inline ::google::protobuf::uint32 RoomUser::fa() const {
  return fa_;
}
inline void RoomUser::set_fa(::google::protobuf::uint32 value) {
  set_has_fa();
  fa_ = value;
}

// optional uint32 piao = 18;
inline bool RoomUser::has_piao() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RoomUser::set_has_piao() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RoomUser::clear_has_piao() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RoomUser::clear_piao() {
  piao_ = 0u;
  clear_has_piao();
}
inline ::google::protobuf::uint32 RoomUser::piao() const {
  return piao_;
}
inline void RoomUser::set_piao(::google::protobuf::uint32 value) {
  set_has_piao();
  piao_ = value;
}

// optional bool ready = 19;
inline bool RoomUser::has_ready() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RoomUser::set_has_ready() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RoomUser::clear_has_ready() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RoomUser::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool RoomUser::ready() const {
  return ready_;
}
inline void RoomUser::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
}

// optional bool begin = 20;
inline bool RoomUser::has_begin() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RoomUser::set_has_begin() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RoomUser::clear_has_begin() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RoomUser::clear_begin() {
  begin_ = false;
  clear_has_begin();
}
inline bool RoomUser::begin() const {
  return begin_;
}
inline void RoomUser::set_begin(bool value) {
  set_has_begin();
  begin_ = value;
}

// optional bool zhuang = 21;
inline bool RoomUser::has_zhuang() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RoomUser::set_has_zhuang() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RoomUser::clear_has_zhuang() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RoomUser::clear_zhuang() {
  zhuang_ = false;
  clear_has_zhuang();
}
inline bool RoomUser::zhuang() const {
  return zhuang_;
}
inline void RoomUser::set_zhuang(bool value) {
  set_has_zhuang();
  zhuang_ = value;
}

// optional bool online = 22;
inline bool RoomUser::has_online() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RoomUser::set_has_online() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RoomUser::clear_has_online() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RoomUser::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool RoomUser::online() const {
  return online_;
}
inline void RoomUser::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// -------------------------------------------------------------------

// TingCard

// optional uint32 card = 1;
inline bool TingCard::has_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TingCard::set_has_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TingCard::clear_has_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TingCard::clear_card() {
  card_ = 0u;
  clear_has_card();
}
inline ::google::protobuf::uint32 TingCard::card() const {
  return card_;
}
inline void TingCard::set_card(::google::protobuf::uint32 value) {
  set_has_card();
  card_ = value;
}

// optional bytes ting = 2;
inline bool TingCard::has_ting() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TingCard::set_has_ting() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TingCard::clear_has_ting() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TingCard::clear_ting() {
  if (ting_ != &::google::protobuf::internal::kEmptyString) {
    ting_->clear();
  }
  clear_has_ting();
}
inline const ::std::string& TingCard::ting() const {
  return *ting_;
}
inline void TingCard::set_ting(const ::std::string& value) {
  set_has_ting();
  if (ting_ == &::google::protobuf::internal::kEmptyString) {
    ting_ = new ::std::string;
  }
  ting_->assign(value);
}
inline void TingCard::set_ting(const char* value) {
  set_has_ting();
  if (ting_ == &::google::protobuf::internal::kEmptyString) {
    ting_ = new ::std::string;
  }
  ting_->assign(value);
}
inline void TingCard::set_ting(const void* value, size_t size) {
  set_has_ting();
  if (ting_ == &::google::protobuf::internal::kEmptyString) {
    ting_ = new ::std::string;
  }
  ting_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TingCard::mutable_ting() {
  set_has_ting();
  if (ting_ == &::google::protobuf::internal::kEmptyString) {
    ting_ = new ::std::string;
  }
  return ting_;
}
inline ::std::string* TingCard::release_ting() {
  clear_has_ting();
  if (ting_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ting_;
    ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TingCard::set_allocated_ting(::std::string* ting) {
  if (ting_ != &::google::protobuf::internal::kEmptyString) {
    delete ting_;
  }
  if (ting) {
    set_has_ting();
    ting_ = ting;
  } else {
    clear_has_ting();
    ting_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserOver

// optional string userid = 1;
inline bool UserOver::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOver::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOver::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOver::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UserOver::userid() const {
  return *userid_;
}
inline void UserOver::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserOver::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserOver::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserOver::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* UserOver::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserOver::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 position = 2;
inline bool UserOver::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOver::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOver::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOver::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 UserOver::position() const {
  return position_;
}
inline void UserOver::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional uint32 score = 3;
inline bool UserOver::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserOver::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserOver::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserOver::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 UserOver::score() const {
  return score_;
}
inline void UserOver::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 total = 4;
inline bool UserOver::has_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserOver::set_has_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserOver::clear_has_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserOver::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserOver::total() const {
  return total_;
}
inline void UserOver::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional bytes cards = 5;
inline bool UserOver::has_cards() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserOver::set_has_cards() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserOver::clear_has_cards() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserOver::clear_cards() {
  if (cards_ != &::google::protobuf::internal::kEmptyString) {
    cards_->clear();
  }
  clear_has_cards();
}
inline const ::std::string& UserOver::cards() const {
  return *cards_;
}
inline void UserOver::set_cards(const ::std::string& value) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(value);
}
inline void UserOver::set_cards(const char* value) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(value);
}
inline void UserOver::set_cards(const void* value, size_t size) {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  cards_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserOver::mutable_cards() {
  set_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    cards_ = new ::std::string;
  }
  return cards_;
}
inline ::std::string* UserOver::release_cards() {
  clear_has_cards();
  if (cards_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cards_;
    cards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserOver::set_allocated_cards(::std::string* cards) {
  if (cards_ != &::google::protobuf::internal::kEmptyString) {
    delete cards_;
  }
  if (cards) {
    set_has_cards();
    cards_ = cards;
  } else {
    clear_has_cards();
    cards_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserRound

// optional string userid = 1;
inline bool UserRound::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRound::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRound::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRound::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& UserRound::userid() const {
  return *userid_;
}
inline void UserRound::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserRound::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void UserRound::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserRound::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* UserRound::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserRound::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 total = 2;
inline bool UserRound::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRound::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRound::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRound::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserRound::total() const {
  return total_;
}
inline void UserRound::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional string pao = 3;
inline bool UserRound::has_pao() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRound::set_has_pao() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRound::clear_has_pao() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRound::clear_pao() {
  if (pao_ != &::google::protobuf::internal::kEmptyString) {
    pao_->clear();
  }
  clear_has_pao();
}
inline const ::std::string& UserRound::pao() const {
  return *pao_;
}
inline void UserRound::set_pao(const ::std::string& value) {
  set_has_pao();
  if (pao_ == &::google::protobuf::internal::kEmptyString) {
    pao_ = new ::std::string;
  }
  pao_->assign(value);
}
inline void UserRound::set_pao(const char* value) {
  set_has_pao();
  if (pao_ == &::google::protobuf::internal::kEmptyString) {
    pao_ = new ::std::string;
  }
  pao_->assign(value);
}
inline void UserRound::set_pao(const char* value, size_t size) {
  set_has_pao();
  if (pao_ == &::google::protobuf::internal::kEmptyString) {
    pao_ = new ::std::string;
  }
  pao_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserRound::mutable_pao() {
  set_has_pao();
  if (pao_ == &::google::protobuf::internal::kEmptyString) {
    pao_ = new ::std::string;
  }
  return pao_;
}
inline ::std::string* UserRound::release_pao() {
  clear_has_pao();
  if (pao_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pao_;
    pao_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserRound::set_allocated_pao(::std::string* pao) {
  if (pao_ != &::google::protobuf::internal::kEmptyString) {
    delete pao_;
  }
  if (pao) {
    set_has_pao();
    pao_ = pao;
  } else {
    clear_has_pao();
    pao_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string win = 4;
inline bool UserRound::has_win() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRound::set_has_win() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRound::clear_has_win() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRound::clear_win() {
  if (win_ != &::google::protobuf::internal::kEmptyString) {
    win_->clear();
  }
  clear_has_win();
}
inline const ::std::string& UserRound::win() const {
  return *win_;
}
inline void UserRound::set_win(const ::std::string& value) {
  set_has_win();
  if (win_ == &::google::protobuf::internal::kEmptyString) {
    win_ = new ::std::string;
  }
  win_->assign(value);
}
inline void UserRound::set_win(const char* value) {
  set_has_win();
  if (win_ == &::google::protobuf::internal::kEmptyString) {
    win_ = new ::std::string;
  }
  win_->assign(value);
}
inline void UserRound::set_win(const char* value, size_t size) {
  set_has_win();
  if (win_ == &::google::protobuf::internal::kEmptyString) {
    win_ = new ::std::string;
  }
  win_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserRound::mutable_win() {
  set_has_win();
  if (win_ == &::google::protobuf::internal::kEmptyString) {
    win_ = new ::std::string;
  }
  return win_;
}
inline ::std::string* UserRound::release_win() {
  clear_has_win();
  if (win_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = win_;
    win_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserRound::set_allocated_win(::std::string* win) {
  if (win_ != &::google::protobuf::internal::kEmptyString) {
    delete win_;
  }
  if (win) {
    set_has_win();
    win_ = win;
  } else {
    clear_has_win();
    win_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CPing

// optional uint32 cmd = 1 [default = 16387];
inline bool CPing::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CPing::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CPing::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CPing::clear_cmd() {
  cmd_ = 16387u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CPing::cmd() const {
  return cmd_;
}
inline void CPing::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// -------------------------------------------------------------------

// SPing

// optional uint32 cmd = 1 [default = 16387];
inline bool SPing::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SPing::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SPing::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SPing::clear_cmd() {
  cmd_ = 16387u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SPing::cmd() const {
  return cmd_;
}
inline void SPing::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Vo_2eproto__INCLUDED
