// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Room.proto

#ifndef PROTOBUF_Room_2eproto__INCLUDED
#define PROTOBUF_Room_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Vo.h"
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Room_2eproto();
void protobuf_AssignDesc_Room_2eproto();
void protobuf_ShutdownFile_Room_2eproto();

class CHMMJCreateRoom;
class SHMMJCreateRoom;
class CHMMJEnterRoom;
class SHMMJEnterRoom;
class SComein;
class CBegin;
class SBegin;
class CReady;
class SReady;
class CLeave;
class SLeave;
class CLine;
class SLine;
class CDissolveRoom;
class SDissolveRoom;
class CVote;
class SVote;
class SVoteResult;
class CRChat;
class SRChat;

// ===================================================================

class CHMMJCreateRoom : public ::google::protobuf::Message {
 public:
  CHMMJCreateRoom();
  virtual ~CHMMJCreateRoom();

  CHMMJCreateRoom(const CHMMJCreateRoom& from);

  inline CHMMJCreateRoom& operator=(const CHMMJCreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHMMJCreateRoom& default_instance();

  void Swap(CHMMJCreateRoom* other);

  // implements Message ----------------------------------------------

  CHMMJCreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHMMJCreateRoom& from);
  void MergeFrom(const CHMMJCreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28672];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 ante = 3;
  inline bool has_ante() const;
  inline void clear_ante();
  static const int kAnteFieldNumber = 3;
  inline ::google::protobuf::uint32 ante() const;
  inline void set_ante(::google::protobuf::uint32 value);

  // optional uint32 round = 4;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 4;
  inline ::google::protobuf::uint32 round() const;
  inline void set_round(::google::protobuf::uint32 value);

  // optional uint32 bao = 5;
  inline bool has_bao() const;
  inline void clear_bao();
  static const int kBaoFieldNumber = 5;
  inline ::google::protobuf::uint32 bao() const;
  inline void set_bao(::google::protobuf::uint32 value);

  // optional uint32 bang = 6;
  inline bool has_bang() const;
  inline void clear_bang();
  static const int kBangFieldNumber = 6;
  inline ::google::protobuf::uint32 bang() const;
  inline void set_bang(::google::protobuf::uint32 value);

  // optional string uid = 7;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 7;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CHMMJCreateRoom)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ante();
  inline void clear_has_ante();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_bao();
  inline void clear_has_bao();
  inline void set_has_bang();
  inline void clear_has_bang();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 ante_;
  ::google::protobuf::uint32 round_;
  ::google::protobuf::uint32 bao_;
  ::google::protobuf::uint32 bang_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CHMMJCreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class SHMMJCreateRoom : public ::google::protobuf::Message {
 public:
  SHMMJCreateRoom();
  virtual ~SHMMJCreateRoom();

  SHMMJCreateRoom(const SHMMJCreateRoom& from);

  inline SHMMJCreateRoom& operator=(const SHMMJCreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SHMMJCreateRoom& default_instance();

  void Swap(SHMMJCreateRoom* other);

  // implements Message ----------------------------------------------

  SHMMJCreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SHMMJCreateRoom& from);
  void MergeFrom(const SHMMJCreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28672];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional .protocol.RoomData roomdata = 2;
  inline bool has_roomdata() const;
  inline void clear_roomdata();
  static const int kRoomdataFieldNumber = 2;
  inline const ::protocol::RoomData& roomdata() const;
  inline ::protocol::RoomData* mutable_roomdata();
  inline ::protocol::RoomData* release_roomdata();
  inline void set_allocated_roomdata(::protocol::RoomData* roomdata);

  // optional .protocol.RoomUser roomuser = 3;
  inline bool has_roomuser() const;
  inline void clear_roomuser();
  static const int kRoomuserFieldNumber = 3;
  inline const ::protocol::RoomUser& roomuser() const;
  inline ::protocol::RoomUser* mutable_roomuser();
  inline ::protocol::RoomUser* release_roomuser();
  inline void set_allocated_roomuser(::protocol::RoomUser* roomuser);

  // optional uint32 err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SHMMJCreateRoom)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_roomdata();
  inline void clear_has_roomdata();
  inline void set_has_roomuser();
  inline void clear_has_roomuser();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::RoomData* roomdata_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 err_;
  ::protocol::RoomUser* roomuser_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SHMMJCreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class CHMMJEnterRoom : public ::google::protobuf::Message {
 public:
  CHMMJEnterRoom();
  virtual ~CHMMJEnterRoom();

  CHMMJEnterRoom(const CHMMJEnterRoom& from);

  inline CHMMJEnterRoom& operator=(const CHMMJEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CHMMJEnterRoom& default_instance();

  void Swap(CHMMJEnterRoom* other);

  // implements Message ----------------------------------------------

  CHMMJEnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CHMMJEnterRoom& from);
  void MergeFrom(const CHMMJEnterRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28673];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string roomid = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional uint32 rtype = 3;
  inline bool has_rtype() const;
  inline void clear_rtype();
  static const int kRtypeFieldNumber = 3;
  inline ::google::protobuf::uint32 rtype() const;
  inline void set_rtype(::google::protobuf::uint32 value);

  // optional string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CHMMJEnterRoom)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_rtype();
  inline void clear_has_rtype();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 rtype_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CHMMJEnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class SHMMJEnterRoom : public ::google::protobuf::Message {
 public:
  SHMMJEnterRoom();
  virtual ~SHMMJEnterRoom();

  SHMMJEnterRoom(const SHMMJEnterRoom& from);

  inline SHMMJEnterRoom& operator=(const SHMMJEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SHMMJEnterRoom& default_instance();

  void Swap(SHMMJEnterRoom* other);

  // implements Message ----------------------------------------------

  SHMMJEnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SHMMJEnterRoom& from);
  void MergeFrom(const SHMMJEnterRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28673];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional .protocol.RoomData roomdata = 2;
  inline bool has_roomdata() const;
  inline void clear_roomdata();
  static const int kRoomdataFieldNumber = 2;
  inline const ::protocol::RoomData& roomdata() const;
  inline ::protocol::RoomData* mutable_roomdata();
  inline ::protocol::RoomData* release_roomdata();
  inline void set_allocated_roomdata(::protocol::RoomData* roomdata);

  // repeated .protocol.RoomUser roomusers = 3;
  inline int roomusers_size() const;
  inline void clear_roomusers();
  static const int kRoomusersFieldNumber = 3;
  inline const ::protocol::RoomUser& roomusers(int index) const;
  inline ::protocol::RoomUser* mutable_roomusers(int index);
  inline ::protocol::RoomUser* add_roomusers();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::RoomUser >&
      roomusers() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::RoomUser >*
      mutable_roomusers();

  // repeated .protocol.SVote sv = 4;
  inline int sv_size() const;
  inline void clear_sv();
  static const int kSvFieldNumber = 4;
  inline const ::protocol::SVote& sv(int index) const;
  inline ::protocol::SVote* mutable_sv(int index);
  inline ::protocol::SVote* add_sv();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::SVote >&
      sv() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::SVote >*
      mutable_sv();

  // optional string uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional bool begin = 6;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 6;
  inline bool begin() const;
  inline void set_begin(bool value);

  // optional uint32 err = 7;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 7;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SHMMJEnterRoom)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_roomdata();
  inline void clear_has_roomdata();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::RoomData* roomdata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::RoomUser > roomusers_;
  ::google::protobuf::uint32 cmd_;
  bool begin_;
  ::google::protobuf::RepeatedPtrField< ::protocol::SVote > sv_;
  ::std::string* uid_;
  ::google::protobuf::uint32 err_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SHMMJEnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class SComein : public ::google::protobuf::Message {
 public:
  SComein();
  virtual ~SComein();

  SComein(const SComein& from);

  inline SComein& operator=(const SComein& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SComein& default_instance();

  void Swap(SComein* other);

  // implements Message ----------------------------------------------

  SComein* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SComein& from);
  void MergeFrom(const SComein& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28674];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional .protocol.RoomUser roomuser = 2;
  inline bool has_roomuser() const;
  inline void clear_roomuser();
  static const int kRoomuserFieldNumber = 2;
  inline const ::protocol::RoomUser& roomuser() const;
  inline ::protocol::RoomUser* mutable_roomuser();
  inline ::protocol::RoomUser* release_roomuser();
  inline void set_allocated_roomuser(::protocol::RoomUser* roomuser);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.SComein)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_roomuser();
  inline void clear_has_roomuser();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::protocol::RoomUser* roomuser_;
  ::std::string* uid_;
  ::google::protobuf::uint32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SComein* default_instance_;
};
// -------------------------------------------------------------------

class CBegin : public ::google::protobuf::Message {
 public:
  CBegin();
  virtual ~CBegin();

  CBegin(const CBegin& from);

  inline CBegin& operator=(const CBegin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CBegin& default_instance();

  void Swap(CBegin* other);

  // implements Message ----------------------------------------------

  CBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CBegin& from);
  void MergeFrom(const CBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28675];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CBegin)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 type_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CBegin* default_instance_;
};
// -------------------------------------------------------------------

class SBegin : public ::google::protobuf::Message {
 public:
  SBegin();
  virtual ~SBegin();

  SBegin(const SBegin& from);

  inline SBegin& operator=(const SBegin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SBegin& default_instance();

  void Swap(SBegin* other);

  // implements Message ----------------------------------------------

  SBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SBegin& from);
  void MergeFrom(const SBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28675];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SBegin)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 type_;
  ::std::string* uid_;
  ::google::protobuf::uint32 err_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SBegin* default_instance_;
};
// -------------------------------------------------------------------

class CReady : public ::google::protobuf::Message {
 public:
  CReady();
  virtual ~CReady();

  CReady(const CReady& from);

  inline CReady& operator=(const CReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CReady& default_instance();

  void Swap(CReady* other);

  // implements Message ----------------------------------------------

  CReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CReady& from);
  void MergeFrom(const CReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28676];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool ready = 2;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 2;
  inline bool ready() const;
  inline void set_ready(bool value);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CReady)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool ready_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CReady* default_instance_;
};
// -------------------------------------------------------------------

class SReady : public ::google::protobuf::Message {
 public:
  SReady();
  virtual ~SReady();

  SReady(const SReady& from);

  inline SReady& operator=(const SReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SReady& default_instance();

  void Swap(SReady* other);

  // implements Message ----------------------------------------------

  SReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SReady& from);
  void MergeFrom(const SReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28676];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool ready = 2;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 2;
  inline bool ready() const;
  inline void set_ready(bool value);

  // optional uint32 position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string suid = 5;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 5;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // optional uint32 err = 6;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 6;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SReady)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_ready();
  inline void clear_has_ready();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_suid();
  inline void clear_has_suid();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool ready_;
  ::std::string* uid_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::uint32 err_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SReady* default_instance_;
};
// -------------------------------------------------------------------

class CLeave : public ::google::protobuf::Message {
 public:
  CLeave();
  virtual ~CLeave();

  CLeave(const CLeave& from);

  inline CLeave& operator=(const CLeave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CLeave& default_instance();

  void Swap(CLeave* other);

  // implements Message ----------------------------------------------

  CLeave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CLeave& from);
  void MergeFrom(const CLeave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28677];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional bool zhudong = 3;
  inline bool has_zhudong() const;
  inline void clear_zhudong();
  static const int kZhudongFieldNumber = 3;
  inline bool zhudong() const;
  inline void set_zhudong(bool value);

  // @@protoc_insertion_point(class_scope:protocol.CLeave)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_zhudong();
  inline void clear_has_zhudong();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 cmd_;
  bool zhudong_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CLeave* default_instance_;
};
// -------------------------------------------------------------------

class SLeave : public ::google::protobuf::Message {
 public:
  SLeave();
  virtual ~SLeave();

  SLeave(const SLeave& from);

  inline SLeave& operator=(const SLeave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SLeave& default_instance();

  void Swap(SLeave* other);

  // implements Message ----------------------------------------------

  SLeave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLeave& from);
  void MergeFrom(const SLeave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28677];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string suid = 3;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 3;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // optional uint32 err = 4;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 4;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SLeave)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_suid();
  inline void clear_has_suid();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 err_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SLeave* default_instance_;
};
// -------------------------------------------------------------------

class CLine : public ::google::protobuf::Message {
 public:
  CLine();
  virtual ~CLine();

  CLine(const CLine& from);

  inline CLine& operator=(const CLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CLine& default_instance();

  void Swap(CLine* other);

  // implements Message ----------------------------------------------

  CLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CLine& from);
  void MergeFrom(const CLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28678];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline bool online() const;
  inline void set_online(bool value);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CLine)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool online_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CLine* default_instance_;
};
// -------------------------------------------------------------------

class SLine : public ::google::protobuf::Message {
 public:
  SLine();
  virtual ~SLine();

  SLine(const SLine& from);

  inline SLine& operator=(const SLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SLine& default_instance();

  void Swap(SLine* other);

  // implements Message ----------------------------------------------

  SLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SLine& from);
  void MergeFrom(const SLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28678];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline bool online() const;
  inline void set_online(bool value);

  // optional uint32 position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string suid = 5;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 5;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // optional uint32 err = 6;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 6;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SLine)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_suid();
  inline void clear_has_suid();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool online_;
  ::std::string* uid_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::uint32 err_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SLine* default_instance_;
};
// -------------------------------------------------------------------

class CDissolveRoom : public ::google::protobuf::Message {
 public:
  CDissolveRoom();
  virtual ~CDissolveRoom();

  CDissolveRoom(const CDissolveRoom& from);

  inline CDissolveRoom& operator=(const CDissolveRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDissolveRoom& default_instance();

  void Swap(CDissolveRoom* other);

  // implements Message ----------------------------------------------

  CDissolveRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDissolveRoom& from);
  void MergeFrom(const CDissolveRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28679];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string rid = 2;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRidFieldNumber = 2;
  inline const ::std::string& rid() const;
  inline void set_rid(const ::std::string& value);
  inline void set_rid(const char* value);
  inline void set_rid(const char* value, size_t size);
  inline ::std::string* mutable_rid();
  inline ::std::string* release_rid();
  inline void set_allocated_rid(::std::string* rid);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CDissolveRoom)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rid_;
  ::std::string* uid_;
  ::google::protobuf::uint32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CDissolveRoom* default_instance_;
};
// -------------------------------------------------------------------

class SDissolveRoom : public ::google::protobuf::Message {
 public:
  SDissolveRoom();
  virtual ~SDissolveRoom();

  SDissolveRoom(const SDissolveRoom& from);

  inline SDissolveRoom& operator=(const SDissolveRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SDissolveRoom& default_instance();

  void Swap(SDissolveRoom* other);

  // implements Message ----------------------------------------------

  SDissolveRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDissolveRoom& from);
  void MergeFrom(const SDissolveRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28679];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string rid = 2;
  inline bool has_rid() const;
  inline void clear_rid();
  static const int kRidFieldNumber = 2;
  inline const ::std::string& rid() const;
  inline void set_rid(const ::std::string& value);
  inline void set_rid(const char* value);
  inline void set_rid(const char* value, size_t size);
  inline ::std::string* mutable_rid();
  inline ::std::string* release_rid();
  inline void set_allocated_rid(::std::string* rid);

  // optional uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional string uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string suid = 6;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 6;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // optional uint32 err = 7;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 7;
  inline ::google::protobuf::uint32 err() const;
  inline void set_err(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.SDissolveRoom)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_rid();
  inline void clear_has_rid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_suid();
  inline void clear_has_suid();
  inline void set_has_err();
  inline void clear_has_err();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rid_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 time_;
  ::std::string* uid_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::uint32 err_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SDissolveRoom* default_instance_;
};
// -------------------------------------------------------------------

class CVote : public ::google::protobuf::Message {
 public:
  CVote();
  virtual ~CVote();

  CVote(const CVote& from);

  inline CVote& operator=(const CVote& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVote& default_instance();

  void Swap(CVote* other);

  // implements Message ----------------------------------------------

  CVote* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CVote& from);
  void MergeFrom(const CVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28680];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool agree = 2;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 2;
  inline bool agree() const;
  inline void set_agree(bool value);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CVote)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool agree_;
  ::std::string* uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CVote* default_instance_;
};
// -------------------------------------------------------------------

class SVote : public ::google::protobuf::Message {
 public:
  SVote();
  virtual ~SVote();

  SVote(const SVote& from);

  inline SVote& operator=(const SVote& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SVote& default_instance();

  void Swap(SVote* other);

  // implements Message ----------------------------------------------

  SVote* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SVote& from);
  void MergeFrom(const SVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28680];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool agree = 2;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 2;
  inline bool agree() const;
  inline void set_agree(bool value);

  // optional uint32 position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string suid = 5;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 5;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // @@protoc_insertion_point(class_scope:protocol.SVote)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_suid();
  inline void clear_has_suid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool agree_;
  ::std::string* uid_;
  ::std::string* suid_;
  ::google::protobuf::uint32 position_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SVote* default_instance_;
};
// -------------------------------------------------------------------

class SVoteResult : public ::google::protobuf::Message {
 public:
  SVoteResult();
  virtual ~SVoteResult();

  SVoteResult(const SVoteResult& from);

  inline SVoteResult& operator=(const SVoteResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SVoteResult& default_instance();

  void Swap(SVoteResult* other);

  // implements Message ----------------------------------------------

  SVoteResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SVoteResult& from);
  void MergeFrom(const SVoteResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28681];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional bool dissolve = 2;
  inline bool has_dissolve() const;
  inline void clear_dissolve();
  static const int kDissolveFieldNumber = 2;
  inline bool dissolve() const;
  inline void set_dissolve(bool value);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string suid = 5;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 5;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // @@protoc_insertion_point(class_scope:protocol.SVoteResult)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_dissolve();
  inline void clear_has_dissolve();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_suid();
  inline void clear_has_suid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cmd_;
  bool dissolve_;
  ::std::string* uid_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SVoteResult* default_instance_;
};
// -------------------------------------------------------------------

class CRChat : public ::google::protobuf::Message {
 public:
  CRChat();
  virtual ~CRChat();

  CRChat(const CRChat& from);

  inline CRChat& operator=(const CRChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRChat& default_instance();

  void Swap(CRChat* other);

  // implements Message ----------------------------------------------

  CRChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRChat& from);
  void MergeFrom(const CRChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28682];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:protocol.CRChat)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::std::string* uid_;
  ::google::protobuf::uint32 cmd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static CRChat* default_instance_;
};
// -------------------------------------------------------------------

class SRChat : public ::google::protobuf::Message {
 public:
  SRChat();
  virtual ~SRChat();

  SRChat(const SRChat& from);

  inline SRChat& operator=(const SRChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SRChat& default_instance();

  void Swap(SRChat* other);

  // implements Message ----------------------------------------------

  SRChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SRChat& from);
  void MergeFrom(const SRChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cmd = 1 [default = 28682];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional string suid = 5;
  inline bool has_suid() const;
  inline void clear_suid();
  static const int kSuidFieldNumber = 5;
  inline const ::std::string& suid() const;
  inline void set_suid(const ::std::string& value);
  inline void set_suid(const char* value);
  inline void set_suid(const char* value, size_t size);
  inline ::std::string* mutable_suid();
  inline ::std::string* release_suid();
  inline void set_allocated_suid(::std::string* suid);

  // @@protoc_insertion_point(class_scope:protocol.SRChat)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_suid();
  inline void clear_has_suid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  ::google::protobuf::uint32 cmd_;
  ::google::protobuf::uint32 pos_;
  ::std::string* uid_;
  ::std::string* suid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Room_2eproto();
  friend void protobuf_AssignDesc_Room_2eproto();
  friend void protobuf_ShutdownFile_Room_2eproto();

  void InitAsDefaultInstance();
  static SRChat* default_instance_;
};
// ===================================================================


// ===================================================================

// CHMMJCreateRoom

// optional uint32 cmd = 1 [default = 28672];
inline bool CHMMJCreateRoom::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHMMJCreateRoom::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHMMJCreateRoom::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHMMJCreateRoom::clear_cmd() {
  cmd_ = 28672u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CHMMJCreateRoom::cmd() const {
  return cmd_;
}
inline void CHMMJCreateRoom::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 type = 2;
inline bool CHMMJCreateRoom::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CHMMJCreateRoom::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CHMMJCreateRoom::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CHMMJCreateRoom::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CHMMJCreateRoom::type() const {
  return type_;
}
inline void CHMMJCreateRoom::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 ante = 3;
inline bool CHMMJCreateRoom::has_ante() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CHMMJCreateRoom::set_has_ante() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CHMMJCreateRoom::clear_has_ante() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CHMMJCreateRoom::clear_ante() {
  ante_ = 0u;
  clear_has_ante();
}
inline ::google::protobuf::uint32 CHMMJCreateRoom::ante() const {
  return ante_;
}
inline void CHMMJCreateRoom::set_ante(::google::protobuf::uint32 value) {
  set_has_ante();
  ante_ = value;
}

// optional uint32 round = 4;
inline bool CHMMJCreateRoom::has_round() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CHMMJCreateRoom::set_has_round() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CHMMJCreateRoom::clear_has_round() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CHMMJCreateRoom::clear_round() {
  round_ = 0u;
  clear_has_round();
}
inline ::google::protobuf::uint32 CHMMJCreateRoom::round() const {
  return round_;
}
inline void CHMMJCreateRoom::set_round(::google::protobuf::uint32 value) {
  set_has_round();
  round_ = value;
}

// optional uint32 bao = 5;
inline bool CHMMJCreateRoom::has_bao() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CHMMJCreateRoom::set_has_bao() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CHMMJCreateRoom::clear_has_bao() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CHMMJCreateRoom::clear_bao() {
  bao_ = 0u;
  clear_has_bao();
}
inline ::google::protobuf::uint32 CHMMJCreateRoom::bao() const {
  return bao_;
}
inline void CHMMJCreateRoom::set_bao(::google::protobuf::uint32 value) {
  set_has_bao();
  bao_ = value;
}

// optional uint32 bang = 6;
inline bool CHMMJCreateRoom::has_bang() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CHMMJCreateRoom::set_has_bang() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CHMMJCreateRoom::clear_has_bang() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CHMMJCreateRoom::clear_bang() {
  bang_ = 0u;
  clear_has_bang();
}
inline ::google::protobuf::uint32 CHMMJCreateRoom::bang() const {
  return bang_;
}
inline void CHMMJCreateRoom::set_bang(::google::protobuf::uint32 value) {
  set_has_bang();
  bang_ = value;
}

// optional string uid = 7;
inline bool CHMMJCreateRoom::has_uid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CHMMJCreateRoom::set_has_uid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CHMMJCreateRoom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CHMMJCreateRoom::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CHMMJCreateRoom::uid() const {
  return *uid_;
}
inline void CHMMJCreateRoom::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CHMMJCreateRoom::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CHMMJCreateRoom::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CHMMJCreateRoom::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CHMMJCreateRoom::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CHMMJCreateRoom::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SHMMJCreateRoom

// optional uint32 cmd = 1 [default = 28672];
inline bool SHMMJCreateRoom::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SHMMJCreateRoom::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SHMMJCreateRoom::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SHMMJCreateRoom::clear_cmd() {
  cmd_ = 28672u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SHMMJCreateRoom::cmd() const {
  return cmd_;
}
inline void SHMMJCreateRoom::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .protocol.RoomData roomdata = 2;
inline bool SHMMJCreateRoom::has_roomdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SHMMJCreateRoom::set_has_roomdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SHMMJCreateRoom::clear_has_roomdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SHMMJCreateRoom::clear_roomdata() {
  if (roomdata_ != NULL) roomdata_->::protocol::RoomData::Clear();
  clear_has_roomdata();
}
inline const ::protocol::RoomData& SHMMJCreateRoom::roomdata() const {
  return roomdata_ != NULL ? *roomdata_ : *default_instance_->roomdata_;
}
inline ::protocol::RoomData* SHMMJCreateRoom::mutable_roomdata() {
  set_has_roomdata();
  if (roomdata_ == NULL) roomdata_ = new ::protocol::RoomData;
  return roomdata_;
}
inline ::protocol::RoomData* SHMMJCreateRoom::release_roomdata() {
  clear_has_roomdata();
  ::protocol::RoomData* temp = roomdata_;
  roomdata_ = NULL;
  return temp;
}
inline void SHMMJCreateRoom::set_allocated_roomdata(::protocol::RoomData* roomdata) {
  delete roomdata_;
  roomdata_ = roomdata;
  if (roomdata) {
    set_has_roomdata();
  } else {
    clear_has_roomdata();
  }
}

// optional .protocol.RoomUser roomuser = 3;
inline bool SHMMJCreateRoom::has_roomuser() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SHMMJCreateRoom::set_has_roomuser() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SHMMJCreateRoom::clear_has_roomuser() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SHMMJCreateRoom::clear_roomuser() {
  if (roomuser_ != NULL) roomuser_->::protocol::RoomUser::Clear();
  clear_has_roomuser();
}
inline const ::protocol::RoomUser& SHMMJCreateRoom::roomuser() const {
  return roomuser_ != NULL ? *roomuser_ : *default_instance_->roomuser_;
}
inline ::protocol::RoomUser* SHMMJCreateRoom::mutable_roomuser() {
  set_has_roomuser();
  if (roomuser_ == NULL) roomuser_ = new ::protocol::RoomUser;
  return roomuser_;
}
inline ::protocol::RoomUser* SHMMJCreateRoom::release_roomuser() {
  clear_has_roomuser();
  ::protocol::RoomUser* temp = roomuser_;
  roomuser_ = NULL;
  return temp;
}
inline void SHMMJCreateRoom::set_allocated_roomuser(::protocol::RoomUser* roomuser) {
  delete roomuser_;
  roomuser_ = roomuser;
  if (roomuser) {
    set_has_roomuser();
  } else {
    clear_has_roomuser();
  }
}

// optional uint32 err = 4;
inline bool SHMMJCreateRoom::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SHMMJCreateRoom::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SHMMJCreateRoom::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SHMMJCreateRoom::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SHMMJCreateRoom::err() const {
  return err_;
}
inline void SHMMJCreateRoom::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// CHMMJEnterRoom

// optional uint32 cmd = 1 [default = 28673];
inline bool CHMMJEnterRoom::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CHMMJEnterRoom::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CHMMJEnterRoom::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CHMMJEnterRoom::clear_cmd() {
  cmd_ = 28673u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CHMMJEnterRoom::cmd() const {
  return cmd_;
}
inline void CHMMJEnterRoom::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string roomid = 2;
inline bool CHMMJEnterRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CHMMJEnterRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CHMMJEnterRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CHMMJEnterRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& CHMMJEnterRoom::roomid() const {
  return *roomid_;
}
inline void CHMMJEnterRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void CHMMJEnterRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void CHMMJEnterRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CHMMJEnterRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* CHMMJEnterRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CHMMJEnterRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 rtype = 3;
inline bool CHMMJEnterRoom::has_rtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CHMMJEnterRoom::set_has_rtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CHMMJEnterRoom::clear_has_rtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CHMMJEnterRoom::clear_rtype() {
  rtype_ = 0u;
  clear_has_rtype();
}
inline ::google::protobuf::uint32 CHMMJEnterRoom::rtype() const {
  return rtype_;
}
inline void CHMMJEnterRoom::set_rtype(::google::protobuf::uint32 value) {
  set_has_rtype();
  rtype_ = value;
}

// optional string uid = 4;
inline bool CHMMJEnterRoom::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CHMMJEnterRoom::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CHMMJEnterRoom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CHMMJEnterRoom::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CHMMJEnterRoom::uid() const {
  return *uid_;
}
inline void CHMMJEnterRoom::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CHMMJEnterRoom::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CHMMJEnterRoom::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CHMMJEnterRoom::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CHMMJEnterRoom::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CHMMJEnterRoom::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SHMMJEnterRoom

// optional uint32 cmd = 1 [default = 28673];
inline bool SHMMJEnterRoom::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SHMMJEnterRoom::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SHMMJEnterRoom::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SHMMJEnterRoom::clear_cmd() {
  cmd_ = 28673u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SHMMJEnterRoom::cmd() const {
  return cmd_;
}
inline void SHMMJEnterRoom::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .protocol.RoomData roomdata = 2;
inline bool SHMMJEnterRoom::has_roomdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SHMMJEnterRoom::set_has_roomdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SHMMJEnterRoom::clear_has_roomdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SHMMJEnterRoom::clear_roomdata() {
  if (roomdata_ != NULL) roomdata_->::protocol::RoomData::Clear();
  clear_has_roomdata();
}
inline const ::protocol::RoomData& SHMMJEnterRoom::roomdata() const {
  return roomdata_ != NULL ? *roomdata_ : *default_instance_->roomdata_;
}
inline ::protocol::RoomData* SHMMJEnterRoom::mutable_roomdata() {
  set_has_roomdata();
  if (roomdata_ == NULL) roomdata_ = new ::protocol::RoomData;
  return roomdata_;
}
inline ::protocol::RoomData* SHMMJEnterRoom::release_roomdata() {
  clear_has_roomdata();
  ::protocol::RoomData* temp = roomdata_;
  roomdata_ = NULL;
  return temp;
}
inline void SHMMJEnterRoom::set_allocated_roomdata(::protocol::RoomData* roomdata) {
  delete roomdata_;
  roomdata_ = roomdata;
  if (roomdata) {
    set_has_roomdata();
  } else {
    clear_has_roomdata();
  }
}

// repeated .protocol.RoomUser roomusers = 3;
inline int SHMMJEnterRoom::roomusers_size() const {
  return roomusers_.size();
}
inline void SHMMJEnterRoom::clear_roomusers() {
  roomusers_.Clear();
}
inline const ::protocol::RoomUser& SHMMJEnterRoom::roomusers(int index) const {
  return roomusers_.Get(index);
}
inline ::protocol::RoomUser* SHMMJEnterRoom::mutable_roomusers(int index) {
  return roomusers_.Mutable(index);
}
inline ::protocol::RoomUser* SHMMJEnterRoom::add_roomusers() {
  return roomusers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::RoomUser >&
SHMMJEnterRoom::roomusers() const {
  return roomusers_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::RoomUser >*
SHMMJEnterRoom::mutable_roomusers() {
  return &roomusers_;
}

// repeated .protocol.SVote sv = 4;
inline int SHMMJEnterRoom::sv_size() const {
  return sv_.size();
}
inline void SHMMJEnterRoom::clear_sv() {
  sv_.Clear();
}
inline const ::protocol::SVote& SHMMJEnterRoom::sv(int index) const {
  return sv_.Get(index);
}
inline ::protocol::SVote* SHMMJEnterRoom::mutable_sv(int index) {
  return sv_.Mutable(index);
}
inline ::protocol::SVote* SHMMJEnterRoom::add_sv() {
  return sv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::SVote >&
SHMMJEnterRoom::sv() const {
  return sv_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::SVote >*
SHMMJEnterRoom::mutable_sv() {
  return &sv_;
}

// optional string uid = 5;
inline bool SHMMJEnterRoom::has_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SHMMJEnterRoom::set_has_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SHMMJEnterRoom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SHMMJEnterRoom::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SHMMJEnterRoom::uid() const {
  return *uid_;
}
inline void SHMMJEnterRoom::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SHMMJEnterRoom::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SHMMJEnterRoom::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SHMMJEnterRoom::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SHMMJEnterRoom::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SHMMJEnterRoom::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool begin = 6;
inline bool SHMMJEnterRoom::has_begin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SHMMJEnterRoom::set_has_begin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SHMMJEnterRoom::clear_has_begin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SHMMJEnterRoom::clear_begin() {
  begin_ = false;
  clear_has_begin();
}
inline bool SHMMJEnterRoom::begin() const {
  return begin_;
}
inline void SHMMJEnterRoom::set_begin(bool value) {
  set_has_begin();
  begin_ = value;
}

// optional uint32 err = 7;
inline bool SHMMJEnterRoom::has_err() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SHMMJEnterRoom::set_has_err() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SHMMJEnterRoom::clear_has_err() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SHMMJEnterRoom::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SHMMJEnterRoom::err() const {
  return err_;
}
inline void SHMMJEnterRoom::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// SComein

// optional uint32 cmd = 1 [default = 28674];
inline bool SComein::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SComein::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SComein::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SComein::clear_cmd() {
  cmd_ = 28674u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SComein::cmd() const {
  return cmd_;
}
inline void SComein::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional .protocol.RoomUser roomuser = 2;
inline bool SComein::has_roomuser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SComein::set_has_roomuser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SComein::clear_has_roomuser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SComein::clear_roomuser() {
  if (roomuser_ != NULL) roomuser_->::protocol::RoomUser::Clear();
  clear_has_roomuser();
}
inline const ::protocol::RoomUser& SComein::roomuser() const {
  return roomuser_ != NULL ? *roomuser_ : *default_instance_->roomuser_;
}
inline ::protocol::RoomUser* SComein::mutable_roomuser() {
  set_has_roomuser();
  if (roomuser_ == NULL) roomuser_ = new ::protocol::RoomUser;
  return roomuser_;
}
inline ::protocol::RoomUser* SComein::release_roomuser() {
  clear_has_roomuser();
  ::protocol::RoomUser* temp = roomuser_;
  roomuser_ = NULL;
  return temp;
}
inline void SComein::set_allocated_roomuser(::protocol::RoomUser* roomuser) {
  delete roomuser_;
  roomuser_ = roomuser;
  if (roomuser) {
    set_has_roomuser();
  } else {
    clear_has_roomuser();
  }
}

// optional string uid = 3;
inline bool SComein::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SComein::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SComein::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SComein::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SComein::uid() const {
  return *uid_;
}
inline void SComein::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SComein::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SComein::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SComein::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SComein::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SComein::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CBegin

// optional uint32 cmd = 1 [default = 28675];
inline bool CBegin::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CBegin::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CBegin::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CBegin::clear_cmd() {
  cmd_ = 28675u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CBegin::cmd() const {
  return cmd_;
}
inline void CBegin::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 type = 2;
inline bool CBegin::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CBegin::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CBegin::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CBegin::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CBegin::type() const {
  return type_;
}
inline void CBegin::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string uid = 3;
inline bool CBegin::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CBegin::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CBegin::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CBegin::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CBegin::uid() const {
  return *uid_;
}
inline void CBegin::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CBegin::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CBegin::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CBegin::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CBegin::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CBegin::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SBegin

// optional uint32 cmd = 1 [default = 28675];
inline bool SBegin::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SBegin::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SBegin::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SBegin::clear_cmd() {
  cmd_ = 28675u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SBegin::cmd() const {
  return cmd_;
}
inline void SBegin::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional uint32 type = 2;
inline bool SBegin::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SBegin::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SBegin::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SBegin::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SBegin::type() const {
  return type_;
}
inline void SBegin::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string uid = 3;
inline bool SBegin::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SBegin::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SBegin::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SBegin::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SBegin::uid() const {
  return *uid_;
}
inline void SBegin::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SBegin::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SBegin::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SBegin::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SBegin::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SBegin::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 err = 4;
inline bool SBegin::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SBegin::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SBegin::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SBegin::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SBegin::err() const {
  return err_;
}
inline void SBegin::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// CReady

// optional uint32 cmd = 1 [default = 28676];
inline bool CReady::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CReady::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CReady::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CReady::clear_cmd() {
  cmd_ = 28676u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CReady::cmd() const {
  return cmd_;
}
inline void CReady::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool ready = 2;
inline bool CReady::has_ready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CReady::set_has_ready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CReady::clear_has_ready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CReady::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool CReady::ready() const {
  return ready_;
}
inline void CReady::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
}

// optional string uid = 3;
inline bool CReady::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CReady::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CReady::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CReady::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CReady::uid() const {
  return *uid_;
}
inline void CReady::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CReady::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CReady::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CReady::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CReady::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CReady::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SReady

// optional uint32 cmd = 1 [default = 28676];
inline bool SReady::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SReady::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SReady::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SReady::clear_cmd() {
  cmd_ = 28676u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SReady::cmd() const {
  return cmd_;
}
inline void SReady::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool ready = 2;
inline bool SReady::has_ready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SReady::set_has_ready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SReady::clear_has_ready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SReady::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool SReady::ready() const {
  return ready_;
}
inline void SReady::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
}

// optional uint32 position = 3;
inline bool SReady::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SReady::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SReady::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SReady::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 SReady::position() const {
  return position_;
}
inline void SReady::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional string uid = 4;
inline bool SReady::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SReady::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SReady::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SReady::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SReady::uid() const {
  return *uid_;
}
inline void SReady::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SReady::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SReady::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SReady::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SReady::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SReady::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suid = 5;
inline bool SReady::has_suid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SReady::set_has_suid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SReady::clear_has_suid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SReady::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SReady::suid() const {
  return *suid_;
}
inline void SReady::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SReady::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SReady::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SReady::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SReady::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SReady::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 err = 6;
inline bool SReady::has_err() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SReady::set_has_err() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SReady::clear_has_err() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SReady::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SReady::err() const {
  return err_;
}
inline void SReady::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// CLeave

// optional uint32 cmd = 1 [default = 28677];
inline bool CLeave::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLeave::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLeave::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLeave::clear_cmd() {
  cmd_ = 28677u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CLeave::cmd() const {
  return cmd_;
}
inline void CLeave::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string uid = 2;
inline bool CLeave::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CLeave::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CLeave::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CLeave::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CLeave::uid() const {
  return *uid_;
}
inline void CLeave::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CLeave::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CLeave::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CLeave::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CLeave::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CLeave::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool zhudong = 3;
inline bool CLeave::has_zhudong() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CLeave::set_has_zhudong() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CLeave::clear_has_zhudong() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CLeave::clear_zhudong() {
  zhudong_ = false;
  clear_has_zhudong();
}
inline bool CLeave::zhudong() const {
  return zhudong_;
}
inline void CLeave::set_zhudong(bool value) {
  set_has_zhudong();
  zhudong_ = value;
}

// -------------------------------------------------------------------

// SLeave

// optional uint32 cmd = 1 [default = 28677];
inline bool SLeave::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLeave::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLeave::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLeave::clear_cmd() {
  cmd_ = 28677u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SLeave::cmd() const {
  return cmd_;
}
inline void SLeave::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string uid = 2;
inline bool SLeave::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLeave::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLeave::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLeave::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SLeave::uid() const {
  return *uid_;
}
inline void SLeave::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLeave::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLeave::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLeave::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SLeave::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SLeave::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suid = 3;
inline bool SLeave::has_suid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLeave::set_has_suid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLeave::clear_has_suid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLeave::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SLeave::suid() const {
  return *suid_;
}
inline void SLeave::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SLeave::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SLeave::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLeave::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SLeave::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SLeave::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 err = 4;
inline bool SLeave::has_err() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLeave::set_has_err() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLeave::clear_has_err() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLeave::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SLeave::err() const {
  return err_;
}
inline void SLeave::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// CLine

// optional uint32 cmd = 1 [default = 28678];
inline bool CLine::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CLine::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CLine::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CLine::clear_cmd() {
  cmd_ = 28678u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CLine::cmd() const {
  return cmd_;
}
inline void CLine::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool online = 2;
inline bool CLine::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CLine::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CLine::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CLine::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool CLine::online() const {
  return online_;
}
inline void CLine::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional string uid = 3;
inline bool CLine::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CLine::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CLine::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CLine::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CLine::uid() const {
  return *uid_;
}
inline void CLine::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CLine::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CLine::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CLine::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CLine::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CLine::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SLine

// optional uint32 cmd = 1 [default = 28678];
inline bool SLine::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SLine::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SLine::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SLine::clear_cmd() {
  cmd_ = 28678u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SLine::cmd() const {
  return cmd_;
}
inline void SLine::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool online = 2;
inline bool SLine::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SLine::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SLine::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SLine::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool SLine::online() const {
  return online_;
}
inline void SLine::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional uint32 position = 3;
inline bool SLine::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SLine::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SLine::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SLine::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 SLine::position() const {
  return position_;
}
inline void SLine::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional string uid = 4;
inline bool SLine::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SLine::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SLine::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SLine::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SLine::uid() const {
  return *uid_;
}
inline void SLine::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLine::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SLine::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLine::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SLine::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SLine::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suid = 5;
inline bool SLine::has_suid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SLine::set_has_suid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SLine::clear_has_suid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SLine::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SLine::suid() const {
  return *suid_;
}
inline void SLine::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SLine::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SLine::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SLine::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SLine::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SLine::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 err = 6;
inline bool SLine::has_err() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SLine::set_has_err() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SLine::clear_has_err() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SLine::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SLine::err() const {
  return err_;
}
inline void SLine::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// CDissolveRoom

// optional uint32 cmd = 1 [default = 28679];
inline bool CDissolveRoom::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDissolveRoom::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDissolveRoom::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDissolveRoom::clear_cmd() {
  cmd_ = 28679u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CDissolveRoom::cmd() const {
  return cmd_;
}
inline void CDissolveRoom::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string rid = 2;
inline bool CDissolveRoom::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDissolveRoom::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDissolveRoom::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDissolveRoom::clear_rid() {
  if (rid_ != &::google::protobuf::internal::kEmptyString) {
    rid_->clear();
  }
  clear_has_rid();
}
inline const ::std::string& CDissolveRoom::rid() const {
  return *rid_;
}
inline void CDissolveRoom::set_rid(const ::std::string& value) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(value);
}
inline void CDissolveRoom::set_rid(const char* value) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(value);
}
inline void CDissolveRoom::set_rid(const char* value, size_t size) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDissolveRoom::mutable_rid() {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  return rid_;
}
inline ::std::string* CDissolveRoom::release_rid() {
  clear_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rid_;
    rid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDissolveRoom::set_allocated_rid(::std::string* rid) {
  if (rid_ != &::google::protobuf::internal::kEmptyString) {
    delete rid_;
  }
  if (rid) {
    set_has_rid();
    rid_ = rid;
  } else {
    clear_has_rid();
    rid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uid = 3;
inline bool CDissolveRoom::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CDissolveRoom::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CDissolveRoom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CDissolveRoom::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CDissolveRoom::uid() const {
  return *uid_;
}
inline void CDissolveRoom::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CDissolveRoom::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CDissolveRoom::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDissolveRoom::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CDissolveRoom::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDissolveRoom::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SDissolveRoom

// optional uint32 cmd = 1 [default = 28679];
inline bool SDissolveRoom::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SDissolveRoom::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SDissolveRoom::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SDissolveRoom::clear_cmd() {
  cmd_ = 28679u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SDissolveRoom::cmd() const {
  return cmd_;
}
inline void SDissolveRoom::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string rid = 2;
inline bool SDissolveRoom::has_rid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SDissolveRoom::set_has_rid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SDissolveRoom::clear_has_rid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SDissolveRoom::clear_rid() {
  if (rid_ != &::google::protobuf::internal::kEmptyString) {
    rid_->clear();
  }
  clear_has_rid();
}
inline const ::std::string& SDissolveRoom::rid() const {
  return *rid_;
}
inline void SDissolveRoom::set_rid(const ::std::string& value) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(value);
}
inline void SDissolveRoom::set_rid(const char* value) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(value);
}
inline void SDissolveRoom::set_rid(const char* value, size_t size) {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  rid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SDissolveRoom::mutable_rid() {
  set_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    rid_ = new ::std::string;
  }
  return rid_;
}
inline ::std::string* SDissolveRoom::release_rid() {
  clear_has_rid();
  if (rid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rid_;
    rid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SDissolveRoom::set_allocated_rid(::std::string* rid) {
  if (rid_ != &::google::protobuf::internal::kEmptyString) {
    delete rid_;
  }
  if (rid) {
    set_has_rid();
    rid_ = rid;
  } else {
    clear_has_rid();
    rid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 time = 3;
inline bool SDissolveRoom::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SDissolveRoom::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SDissolveRoom::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SDissolveRoom::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 SDissolveRoom::time() const {
  return time_;
}
inline void SDissolveRoom::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 position = 4;
inline bool SDissolveRoom::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SDissolveRoom::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SDissolveRoom::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SDissolveRoom::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 SDissolveRoom::position() const {
  return position_;
}
inline void SDissolveRoom::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional string uid = 5;
inline bool SDissolveRoom::has_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SDissolveRoom::set_has_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SDissolveRoom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SDissolveRoom::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SDissolveRoom::uid() const {
  return *uid_;
}
inline void SDissolveRoom::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SDissolveRoom::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SDissolveRoom::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SDissolveRoom::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SDissolveRoom::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SDissolveRoom::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suid = 6;
inline bool SDissolveRoom::has_suid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SDissolveRoom::set_has_suid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SDissolveRoom::clear_has_suid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SDissolveRoom::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SDissolveRoom::suid() const {
  return *suid_;
}
inline void SDissolveRoom::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SDissolveRoom::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SDissolveRoom::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SDissolveRoom::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SDissolveRoom::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SDissolveRoom::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 err = 7;
inline bool SDissolveRoom::has_err() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SDissolveRoom::set_has_err() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SDissolveRoom::clear_has_err() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SDissolveRoom::clear_err() {
  err_ = 0u;
  clear_has_err();
}
inline ::google::protobuf::uint32 SDissolveRoom::err() const {
  return err_;
}
inline void SDissolveRoom::set_err(::google::protobuf::uint32 value) {
  set_has_err();
  err_ = value;
}

// -------------------------------------------------------------------

// CVote

// optional uint32 cmd = 1 [default = 28680];
inline bool CVote::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVote::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVote::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVote::clear_cmd() {
  cmd_ = 28680u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CVote::cmd() const {
  return cmd_;
}
inline void CVote::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool agree = 2;
inline bool CVote::has_agree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVote::set_has_agree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVote::clear_has_agree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVote::clear_agree() {
  agree_ = false;
  clear_has_agree();
}
inline bool CVote::agree() const {
  return agree_;
}
inline void CVote::set_agree(bool value) {
  set_has_agree();
  agree_ = value;
}

// optional string uid = 3;
inline bool CVote::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CVote::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CVote::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CVote::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CVote::uid() const {
  return *uid_;
}
inline void CVote::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CVote::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CVote::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CVote::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CVote::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CVote::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SVote

// optional uint32 cmd = 1 [default = 28680];
inline bool SVote::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SVote::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SVote::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SVote::clear_cmd() {
  cmd_ = 28680u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SVote::cmd() const {
  return cmd_;
}
inline void SVote::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool agree = 2;
inline bool SVote::has_agree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SVote::set_has_agree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SVote::clear_has_agree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SVote::clear_agree() {
  agree_ = false;
  clear_has_agree();
}
inline bool SVote::agree() const {
  return agree_;
}
inline void SVote::set_agree(bool value) {
  set_has_agree();
  agree_ = value;
}

// optional uint32 position = 3;
inline bool SVote::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SVote::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SVote::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SVote::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 SVote::position() const {
  return position_;
}
inline void SVote::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional string uid = 4;
inline bool SVote::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SVote::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SVote::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SVote::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SVote::uid() const {
  return *uid_;
}
inline void SVote::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SVote::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SVote::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVote::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SVote::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVote::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suid = 5;
inline bool SVote::has_suid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SVote::set_has_suid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SVote::clear_has_suid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SVote::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SVote::suid() const {
  return *suid_;
}
inline void SVote::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SVote::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SVote::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVote::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SVote::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVote::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SVoteResult

// optional uint32 cmd = 1 [default = 28681];
inline bool SVoteResult::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SVoteResult::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SVoteResult::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SVoteResult::clear_cmd() {
  cmd_ = 28681u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SVoteResult::cmd() const {
  return cmd_;
}
inline void SVoteResult::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional bool dissolve = 2;
inline bool SVoteResult::has_dissolve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SVoteResult::set_has_dissolve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SVoteResult::clear_has_dissolve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SVoteResult::clear_dissolve() {
  dissolve_ = false;
  clear_has_dissolve();
}
inline bool SVoteResult::dissolve() const {
  return dissolve_;
}
inline void SVoteResult::set_dissolve(bool value) {
  set_has_dissolve();
  dissolve_ = value;
}

// optional string uid = 3;
inline bool SVoteResult::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SVoteResult::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SVoteResult::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SVoteResult::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SVoteResult::uid() const {
  return *uid_;
}
inline void SVoteResult::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SVoteResult::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SVoteResult::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVoteResult::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SVoteResult::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVoteResult::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string suid = 5;
inline bool SVoteResult::has_suid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SVoteResult::set_has_suid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SVoteResult::clear_has_suid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SVoteResult::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SVoteResult::suid() const {
  return *suid_;
}
inline void SVoteResult::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SVoteResult::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SVoteResult::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SVoteResult::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SVoteResult::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SVoteResult::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CRChat

// optional uint32 cmd = 1 [default = 28682];
inline bool CRChat::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRChat::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRChat::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRChat::clear_cmd() {
  cmd_ = 28682u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 CRChat::cmd() const {
  return cmd_;
}
inline void CRChat::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string content = 2;
inline bool CRChat::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CRChat::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CRChat::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CRChat::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& CRChat::content() const {
  return *content_;
}
inline void CRChat::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void CRChat::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void CRChat::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRChat::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* CRChat::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRChat::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uid = 3;
inline bool CRChat::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CRChat::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CRChat::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CRChat::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& CRChat::uid() const {
  return *uid_;
}
inline void CRChat::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CRChat::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void CRChat::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CRChat::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* CRChat::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CRChat::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SRChat

// optional uint32 cmd = 1 [default = 28682];
inline bool SRChat::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SRChat::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SRChat::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SRChat::clear_cmd() {
  cmd_ = 28682u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 SRChat::cmd() const {
  return cmd_;
}
inline void SRChat::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// optional string content = 2;
inline bool SRChat::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SRChat::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SRChat::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SRChat::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& SRChat::content() const {
  return *content_;
}
inline void SRChat::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SRChat::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void SRChat::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRChat::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* SRChat::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRChat::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string uid = 3;
inline bool SRChat::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SRChat::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SRChat::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SRChat::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SRChat::uid() const {
  return *uid_;
}
inline void SRChat::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SRChat::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SRChat::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRChat::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SRChat::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRChat::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 pos = 4;
inline bool SRChat::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SRChat::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SRChat::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SRChat::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 SRChat::pos() const {
  return pos_;
}
inline void SRChat::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string suid = 5;
inline bool SRChat::has_suid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SRChat::set_has_suid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SRChat::clear_has_suid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SRChat::clear_suid() {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    suid_->clear();
  }
  clear_has_suid();
}
inline const ::std::string& SRChat::suid() const {
  return *suid_;
}
inline void SRChat::set_suid(const ::std::string& value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SRChat::set_suid(const char* value) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(value);
}
inline void SRChat::set_suid(const char* value, size_t size) {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  suid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SRChat::mutable_suid() {
  set_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    suid_ = new ::std::string;
  }
  return suid_;
}
inline ::std::string* SRChat::release_suid() {
  clear_has_suid();
  if (suid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suid_;
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SRChat::set_allocated_suid(::std::string* suid) {
  if (suid_ != &::google::protobuf::internal::kEmptyString) {
    delete suid_;
  }
  if (suid) {
    set_has_suid();
    suid_ = suid;
  } else {
    clear_has_suid();
    suid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Room_2eproto__INCLUDED
